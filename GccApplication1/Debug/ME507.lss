
ME507.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000009e  00800100  000016a4  00001738  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000016a4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000afe  0080019e  0080019e  000017d6  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000017d6  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00001808  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000005d8  00000000  00000000  00001844  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00009b26  00000000  00000000  00001e1c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002f22  00000000  00000000  0000b942  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003932  00000000  00000000  0000e864  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000fb8  00000000  00000000  00012198  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000fd0b  00000000  00000000  00013150  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00003c78  00000000  00000000  00022e5b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000500  00000000  00000000  00026ad3  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  00000585  00000000  00000000  00026fd3  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
       4:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
       8:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
       c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      10:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      14:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      18:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      1c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      20:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      24:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      28:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      2c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      30:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      34:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      38:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      3c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      40:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      44:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      48:	0c 94 0b 06 	jmp	0xc16	; 0xc16 <__vector_18>
      4c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      50:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      54:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      58:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      5c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      60:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      64:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      68:	0c 94 08 06 	jmp	0xc10	; 0xc10 <__vector_26>
      6c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      70:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      74:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      78:	0c 94 5e 06 	jmp	0xcbc	; 0xcbc <__vector_30>
      7c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      80:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      84:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      88:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>

0000008c <__ctors_end>:
      8c:	11 24       	eor	r1, r1
      8e:	1f be       	out	0x3f, r1	; 63
      90:	cf ef       	ldi	r28, 0xFF	; 255
      92:	d0 e1       	ldi	r29, 0x10	; 16
      94:	de bf       	out	0x3e, r29	; 62
      96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
      98:	11 e0       	ldi	r17, 0x01	; 1
      9a:	a0 e0       	ldi	r26, 0x00	; 0
      9c:	b1 e0       	ldi	r27, 0x01	; 1
      9e:	e4 ea       	ldi	r30, 0xA4	; 164
      a0:	f6 e1       	ldi	r31, 0x16	; 22
      a2:	02 c0       	rjmp	.+4      	; 0xa8 <__do_copy_data+0x10>
      a4:	05 90       	lpm	r0, Z+
      a6:	0d 92       	st	X+, r0
      a8:	ae 39       	cpi	r26, 0x9E	; 158
      aa:	b1 07       	cpc	r27, r17
      ac:	d9 f7       	brne	.-10     	; 0xa4 <__do_copy_data+0xc>

000000ae <__do_clear_bss>:
      ae:	2c e0       	ldi	r18, 0x0C	; 12
      b0:	ae e9       	ldi	r26, 0x9E	; 158
      b2:	b1 e0       	ldi	r27, 0x01	; 1
      b4:	01 c0       	rjmp	.+2      	; 0xb8 <.do_clear_bss_start>

000000b6 <.do_clear_bss_loop>:
      b6:	1d 92       	st	X+, r1

000000b8 <.do_clear_bss_start>:
      b8:	ac 39       	cpi	r26, 0x9C	; 156
      ba:	b2 07       	cpc	r27, r18
      bc:	e1 f7       	brne	.-8      	; 0xb6 <.do_clear_bss_loop>
      be:	0e 94 c1 0a 	call	0x1582	; 0x1582 <main>
      c2:	0c 94 50 0b 	jmp	0x16a0	; 0x16a0 <_exit>

000000c6 <__bad_interrupt>:
      c6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ca <_ZN11fifth_wheelC1EPKchjP8emstreamP17semi_truck_data_t>:
#define LOCKED_LEVEL 1      //todo: NEED TO REPLACE VALUES WHEN TESTING WITH SERVOS
#define UNLOCKED_LEVEL 2



fifth_wheel::fifth_wheel(const char *a_name, unsigned char a_priority, size_t a_stack_size, emstream *p_ser_dev,
      ca:	9f 92       	push	r9
      cc:	af 92       	push	r10
      ce:	bf 92       	push	r11
      d0:	cf 92       	push	r12
      d2:	df 92       	push	r13
      d4:	ef 92       	push	r14
      d6:	ff 92       	push	r15
      d8:	0f 93       	push	r16
      da:	1f 93       	push	r17
      dc:	cf 93       	push	r28
      de:	df 93       	push	r29
      e0:	ec 01       	movw	r28, r24
      e2:	6b 01       	movw	r12, r22
      e4:	94 2e       	mov	r9, r20
      e6:	59 01       	movw	r10, r18
                         semi_truck_data_t *semi_data_in)
		: servo::servo(),
		TaskBase::TaskBase(a_name, a_priority, a_stack_size, p_ser_dev)
      e8:	0e 94 14 02 	call	0x428	; 0x428 <_ZN5servoC1Ev>
      ec:	95 01       	movw	r18, r10
      ee:	49 2d       	mov	r20, r9
      f0:	b6 01       	movw	r22, r12
      f2:	ce 01       	movw	r24, r28
      f4:	0e 94 b2 06 	call	0xd64	; 0xd64 <_ZN8TaskBaseC1EPKchjP8emstream>
      f8:	8a e0       	ldi	r24, 0x0A	; 10
      fa:	91 e0       	ldi	r25, 0x01	; 1
      fc:	99 83       	std	Y+1, r25	; 0x01
      fe:	88 83       	st	Y, r24
{
    semi_data = semi_data_in;
     100:	fb 8a       	std	Y+19, r15	; 0x13
     102:	ea 8a       	std	Y+18, r14	; 0x12
    state = LOCKED; // fifth wheel starts out locked
     104:	81 e0       	ldi	r24, 0x01	; 1
     106:	8c 8b       	std	Y+20, r24	; 0x14
}
     108:	df 91       	pop	r29
     10a:	cf 91       	pop	r28
     10c:	1f 91       	pop	r17
     10e:	0f 91       	pop	r16
     110:	ff 90       	pop	r15
     112:	ef 90       	pop	r14
     114:	df 90       	pop	r13
     116:	cf 90       	pop	r12
     118:	bf 90       	pop	r11
     11a:	af 90       	pop	r10
     11c:	9f 90       	pop	r9
     11e:	08 95       	ret

00000120 <_ZN11fifth_wheel10lock_servoEv>:

    }
}

void fifth_wheel::lock_servo()
{
     120:	cf 93       	push	r28
     122:	df 93       	push	r29
     124:	ec 01       	movw	r28, r24
    write(LOCKED_LEVEL);
     126:	61 e0       	ldi	r22, 0x01	; 1
     128:	70 e0       	ldi	r23, 0x00	; 0
     12a:	0e 94 15 02 	call	0x42a	; 0x42a <_ZN5servo5writeEi>
    semi_data->actual_5th = LOCKED;
     12e:	ea 89       	ldd	r30, Y+18	; 0x12
     130:	fb 89       	ldd	r31, Y+19	; 0x13
     132:	81 e0       	ldi	r24, 0x01	; 1
     134:	85 87       	std	Z+13, r24	; 0x0d
}
     136:	df 91       	pop	r29
     138:	cf 91       	pop	r28
     13a:	08 95       	ret

0000013c <_ZN11fifth_wheel12unlock_servoEv>:

void fifth_wheel::unlock_servo()
{
     13c:	cf 93       	push	r28
     13e:	df 93       	push	r29
     140:	ec 01       	movw	r28, r24
    write(UNLOCKED_LEVEL);
     142:	62 e0       	ldi	r22, 0x02	; 2
     144:	70 e0       	ldi	r23, 0x00	; 0
     146:	0e 94 15 02 	call	0x42a	; 0x42a <_ZN5servo5writeEi>
    semi_data->actual_5th = UNLOCKED;
     14a:	ea 89       	ldd	r30, Y+18	; 0x12
     14c:	fb 89       	ldd	r31, Y+19	; 0x13
     14e:	15 86       	std	Z+13, r1	; 0x0d
}
     150:	df 91       	pop	r29
     152:	cf 91       	pop	r28
     154:	08 95       	ret

00000156 <_ZN11fifth_wheel3runEv>:
    semi_data = semi_data_in;
    state = LOCKED; // fifth wheel starts out locked
}

void fifth_wheel::run()
{
     156:	ec 01       	movw	r28, r24
    lock_servo();
     158:	0e 94 90 00 	call	0x120	; 0x120 <_ZN11fifth_wheel10lock_servoEv>
    state = LOCKED; // fifth wheel starts out locked
     15c:	81 e0       	ldi	r24, 0x01	; 1
     15e:	8c 8b       	std	Y+20, r24	; 0x14
        }

        else if (state == UNLOCKED) {
            if (semi_data->desired_5th == LOCKED) {
                lock_servo();
                state = LOCKED;
     160:	11 e0       	ldi	r17, 0x01	; 1
    lock_servo();
    state = LOCKED; // fifth wheel starts out locked

    for (;;) {

        if (state == LOCKED) {
     162:	8c 89       	ldd	r24, Y+20	; 0x14
     164:	88 23       	and	r24, r24
     166:	51 f0       	breq	.+20     	; 0x17c <_ZN11fifth_wheel3runEv+0x26>
            if (semi_data->desired_5th == UNLOCKED) {
     168:	ea 89       	ldd	r30, Y+18	; 0x12
     16a:	fb 89       	ldd	r31, Y+19	; 0x13
     16c:	84 85       	ldd	r24, Z+12	; 0x0c
     16e:	81 11       	cpse	r24, r1
     170:	f8 cf       	rjmp	.-16     	; 0x162 <_ZN11fifth_wheel3runEv+0xc>
                unlock_servo();
     172:	ce 01       	movw	r24, r28
     174:	0e 94 9e 00 	call	0x13c	; 0x13c <_ZN11fifth_wheel12unlock_servoEv>
                state = UNLOCKED;
     178:	1c 8a       	std	Y+20, r1	; 0x14
     17a:	f3 cf       	rjmp	.-26     	; 0x162 <_ZN11fifth_wheel3runEv+0xc>
            }
        }

        else if (state == UNLOCKED) {
            if (semi_data->desired_5th == LOCKED) {
     17c:	ea 89       	ldd	r30, Y+18	; 0x12
     17e:	fb 89       	ldd	r31, Y+19	; 0x13
     180:	84 85       	ldd	r24, Z+12	; 0x0c
     182:	88 23       	and	r24, r24
     184:	71 f3       	breq	.-36     	; 0x162 <_ZN11fifth_wheel3runEv+0xc>
                lock_servo();
     186:	ce 01       	movw	r24, r28
     188:	0e 94 90 00 	call	0x120	; 0x120 <_ZN11fifth_wheel10lock_servoEv>
                state = LOCKED;
     18c:	1c 8b       	std	Y+20, r17	; 0x14
     18e:	e9 cf       	rjmp	.-46     	; 0x162 <_ZN11fifth_wheel3runEv+0xc>

00000190 <_ZN12gear_shifter14shift_to_firstEv>:
		}
	}
}

void gear_shifter::shift_to_first()
{
     190:	cf 93       	push	r28
     192:	df 93       	push	r29
     194:	ec 01       	movw	r28, r24
	write(FIRST_GEAR_LEVEL);
     196:	61 e0       	ldi	r22, 0x01	; 1
     198:	70 e0       	ldi	r23, 0x00	; 0
     19a:	0e 94 15 02 	call	0x42a	; 0x42a <_ZN5servo5writeEi>
	semi_data->actual_gear = FIRST_GEAR;
     19e:	ea 89       	ldd	r30, Y+18	; 0x12
     1a0:	fb 89       	ldd	r31, Y+19	; 0x13
     1a2:	81 e0       	ldi	r24, 0x01	; 1
     1a4:	83 87       	std	Z+11, r24	; 0x0b
}
     1a6:	df 91       	pop	r29
     1a8:	cf 91       	pop	r28
     1aa:	08 95       	ret

000001ac <_ZN12gear_shifterC1EPKchjP8emstreamP17semi_truck_data_t>:

#define FIRST_GEAR_LEVEL 1
#define SECOND_GEAR_LEVEL 2
#define THIRD_GEAR_LEVEL 3
	
gear_shifter::gear_shifter(const char *a_name, unsigned char a_priority, size_t a_stack_size, emstream *p_ser_dev,
     1ac:	9f 92       	push	r9
     1ae:	af 92       	push	r10
     1b0:	bf 92       	push	r11
     1b2:	cf 92       	push	r12
     1b4:	df 92       	push	r13
     1b6:	ef 92       	push	r14
     1b8:	ff 92       	push	r15
     1ba:	0f 93       	push	r16
     1bc:	1f 93       	push	r17
     1be:	cf 93       	push	r28
     1c0:	df 93       	push	r29
     1c2:	ec 01       	movw	r28, r24
     1c4:	6b 01       	movw	r12, r22
     1c6:	94 2e       	mov	r9, r20
     1c8:	59 01       	movw	r10, r18
                           semi_truck_data_t *semi_data_in)
		: servo::servo(), 
		TaskBase::TaskBase(a_name, a_priority, a_stack_size, p_ser_dev)
     1ca:	0e 94 14 02 	call	0x428	; 0x428 <_ZN5servoC1Ev>
     1ce:	95 01       	movw	r18, r10
     1d0:	49 2d       	mov	r20, r9
     1d2:	b6 01       	movw	r22, r12
     1d4:	ce 01       	movw	r24, r28
     1d6:	0e 94 b2 06 	call	0xd64	; 0xd64 <_ZN8TaskBaseC1EPKchjP8emstream>
     1da:	82 e1       	ldi	r24, 0x12	; 18
     1dc:	91 e0       	ldi	r25, 0x01	; 1
     1de:	99 83       	std	Y+1, r25	; 0x01
     1e0:	88 83       	st	Y, r24
{
	semi_data = semi_data_in;
     1e2:	fb 8a       	std	Y+19, r15	; 0x13
     1e4:	ea 8a       	std	Y+18, r14	; 0x12
	shift_to_first();
     1e6:	ce 01       	movw	r24, r28
     1e8:	0e 94 c8 00 	call	0x190	; 0x190 <_ZN12gear_shifter14shift_to_firstEv>
	semi_data->desired_gear = FIRST_GEAR;
     1ec:	ea 89       	ldd	r30, Y+18	; 0x12
     1ee:	fb 89       	ldd	r31, Y+19	; 0x13
     1f0:	81 e0       	ldi	r24, 0x01	; 1
     1f2:	82 87       	std	Z+10, r24	; 0x0a
	state = FIRST_GEAR;
     1f4:	8c 87       	std	Y+12, r24	; 0x0c
}
     1f6:	df 91       	pop	r29
     1f8:	cf 91       	pop	r28
     1fa:	1f 91       	pop	r17
     1fc:	0f 91       	pop	r16
     1fe:	ff 90       	pop	r15
     200:	ef 90       	pop	r14
     202:	df 90       	pop	r13
     204:	cf 90       	pop	r12
     206:	bf 90       	pop	r11
     208:	af 90       	pop	r10
     20a:	9f 90       	pop	r9
     20c:	08 95       	ret

0000020e <_ZN12gear_shifter15shift_to_secondEv>:
	write(FIRST_GEAR_LEVEL);
	semi_data->actual_gear = FIRST_GEAR;
}

void gear_shifter::shift_to_second()
{
     20e:	cf 93       	push	r28
     210:	df 93       	push	r29
     212:	ec 01       	movw	r28, r24
	write(SECOND_GEAR_LEVEL);
     214:	62 e0       	ldi	r22, 0x02	; 2
     216:	70 e0       	ldi	r23, 0x00	; 0
     218:	0e 94 15 02 	call	0x42a	; 0x42a <_ZN5servo5writeEi>
	semi_data->actual_gear = SECOND_GEAR;
     21c:	ea 89       	ldd	r30, Y+18	; 0x12
     21e:	fb 89       	ldd	r31, Y+19	; 0x13
     220:	82 e0       	ldi	r24, 0x02	; 2
     222:	83 87       	std	Z+11, r24	; 0x0b
}
     224:	df 91       	pop	r29
     226:	cf 91       	pop	r28
     228:	08 95       	ret

0000022a <_ZN12gear_shifter14shift_to_thirdEv>:

void gear_shifter::shift_to_third()
{
     22a:	cf 93       	push	r28
     22c:	df 93       	push	r29
     22e:	ec 01       	movw	r28, r24
	write(THIRD_GEAR_LEVEL);
     230:	63 e0       	ldi	r22, 0x03	; 3
     232:	70 e0       	ldi	r23, 0x00	; 0
     234:	0e 94 15 02 	call	0x42a	; 0x42a <_ZN5servo5writeEi>
	semi_data->actual_gear = THIRD_GEAR;
     238:	ea 89       	ldd	r30, Y+18	; 0x12
     23a:	fb 89       	ldd	r31, Y+19	; 0x13
     23c:	83 e0       	ldi	r24, 0x03	; 3
     23e:	83 87       	std	Z+11, r24	; 0x0b
}
     240:	df 91       	pop	r29
     242:	cf 91       	pop	r28
     244:	08 95       	ret

00000246 <_ZN12gear_shifter3runEv>:
	semi_data->desired_gear = FIRST_GEAR;
	state = FIRST_GEAR;
}

void gear_shifter::run()
{
     246:	ff 92       	push	r15
     248:	0f 93       	push	r16
     24a:	1f 93       	push	r17
     24c:	cf 93       	push	r28
     24e:	df 93       	push	r29
     250:	ec 01       	movw	r28, r24
	shift_to_first();
     252:	0e 94 c8 00 	call	0x190	; 0x190 <_ZN12gear_shifter14shift_to_firstEv>
				if (semi_data->desired_gear == FIRST_GEAR) {
					shift_to_first();
					state = FIRST_GEAR;
				} else if (semi_data->desired_gear == SECOND_GEAR) {
					shift_to_second();
					state = SECOND_GEAR;
     256:	12 e0       	ldi	r17, 0x02	; 2
				}

			} else if (state == THIRD_GEAR) {
				if (semi_data->desired_gear == FIRST_GEAR) {
					shift_to_first();
					state = FIRST_GEAR;
     258:	01 e0       	ldi	r16, 0x01	; 1
				if (semi_data->desired_gear == FIRST_GEAR) {
					shift_to_first();
					state = FIRST_GEAR;
				} else if (semi_data->desired_gear == THIRD_GEAR) {
					shift_to_third();
					state = THIRD_GEAR;
     25a:	0f 2e       	mov	r0, r31
     25c:	f3 e0       	ldi	r31, 0x03	; 3
     25e:	ff 2e       	mov	r15, r31
     260:	f0 2d       	mov	r31, r0
{
	shift_to_first();

	for (;;) {

		if (state != semi_data->desired_gear) { // if the the same, don't need to actuate servo; should make loop faster
     262:	4c 85       	ldd	r20, Y+12	; 0x0c
     264:	24 2f       	mov	r18, r20
     266:	30 e0       	ldi	r19, 0x00	; 0
     268:	ea 89       	ldd	r30, Y+18	; 0x12
     26a:	fb 89       	ldd	r31, Y+19	; 0x13
     26c:	52 85       	ldd	r21, Z+10	; 0x0a
     26e:	85 2f       	mov	r24, r21
     270:	05 2e       	mov	r0, r21
     272:	00 0c       	add	r0, r0
     274:	99 0b       	sbc	r25, r25
     276:	28 17       	cp	r18, r24
     278:	39 07       	cpc	r19, r25
     27a:	e9 f3       	breq	.-6      	; 0x276 <_ZN12gear_shifter3runEv+0x30>

			if (state == FIRST_GEAR) {
     27c:	41 30       	cpi	r20, 0x01	; 1
     27e:	71 f4       	brne	.+28     	; 0x29c <_ZN12gear_shifter3runEv+0x56>
				if (semi_data->desired_gear == SECOND_GEAR) {
     280:	52 30       	cpi	r21, 0x02	; 2
     282:	29 f4       	brne	.+10     	; 0x28e <_ZN12gear_shifter3runEv+0x48>
					shift_to_second();
     284:	ce 01       	movw	r24, r28
     286:	0e 94 07 01 	call	0x20e	; 0x20e <_ZN12gear_shifter15shift_to_secondEv>
					state = SECOND_GEAR;
     28a:	1c 87       	std	Y+12, r17	; 0x0c
     28c:	ea cf       	rjmp	.-44     	; 0x262 <_ZN12gear_shifter3runEv+0x1c>
				} else if (semi_data->desired_gear == THIRD_GEAR) {
     28e:	53 30       	cpi	r21, 0x03	; 3
     290:	41 f7       	brne	.-48     	; 0x262 <_ZN12gear_shifter3runEv+0x1c>
					shift_to_third();
     292:	ce 01       	movw	r24, r28
     294:	0e 94 15 01 	call	0x22a	; 0x22a <_ZN12gear_shifter14shift_to_thirdEv>
					state = SECOND_GEAR;
     298:	1c 87       	std	Y+12, r17	; 0x0c
     29a:	e3 cf       	rjmp	.-58     	; 0x262 <_ZN12gear_shifter3runEv+0x1c>
				}

			} else if (state == SECOND_GEAR) {
     29c:	42 30       	cpi	r20, 0x02	; 2
     29e:	71 f4       	brne	.+28     	; 0x2bc <_ZN12gear_shifter3runEv+0x76>
				if (semi_data->desired_gear == FIRST_GEAR) {
     2a0:	51 30       	cpi	r21, 0x01	; 1
     2a2:	29 f4       	brne	.+10     	; 0x2ae <_ZN12gear_shifter3runEv+0x68>
					shift_to_first();
     2a4:	ce 01       	movw	r24, r28
     2a6:	0e 94 c8 00 	call	0x190	; 0x190 <_ZN12gear_shifter14shift_to_firstEv>
					state = FIRST_GEAR;
     2aa:	0c 87       	std	Y+12, r16	; 0x0c
     2ac:	da cf       	rjmp	.-76     	; 0x262 <_ZN12gear_shifter3runEv+0x1c>
				} else if (semi_data->desired_gear == THIRD_GEAR) {
     2ae:	53 30       	cpi	r21, 0x03	; 3
     2b0:	c1 f6       	brne	.-80     	; 0x262 <_ZN12gear_shifter3runEv+0x1c>
					shift_to_third();
     2b2:	ce 01       	movw	r24, r28
     2b4:	0e 94 15 01 	call	0x22a	; 0x22a <_ZN12gear_shifter14shift_to_thirdEv>
					state = THIRD_GEAR;
     2b8:	fc 86       	std	Y+12, r15	; 0x0c
     2ba:	d3 cf       	rjmp	.-90     	; 0x262 <_ZN12gear_shifter3runEv+0x1c>
				}

			} else if (state == THIRD_GEAR) {
     2bc:	43 30       	cpi	r20, 0x03	; 3
     2be:	71 f4       	brne	.+28     	; 0x2dc <_ZN12gear_shifter3runEv+0x96>
				if (semi_data->desired_gear == FIRST_GEAR) {
     2c0:	51 30       	cpi	r21, 0x01	; 1
     2c2:	29 f4       	brne	.+10     	; 0x2ce <_ZN12gear_shifter3runEv+0x88>
					shift_to_first();
     2c4:	ce 01       	movw	r24, r28
     2c6:	0e 94 c8 00 	call	0x190	; 0x190 <_ZN12gear_shifter14shift_to_firstEv>
					state = FIRST_GEAR;
     2ca:	0c 87       	std	Y+12, r16	; 0x0c
     2cc:	ca cf       	rjmp	.-108    	; 0x262 <_ZN12gear_shifter3runEv+0x1c>
				} else if (semi_data->desired_gear == SECOND_GEAR) {
     2ce:	52 30       	cpi	r21, 0x02	; 2
     2d0:	41 f6       	brne	.-112    	; 0x262 <_ZN12gear_shifter3runEv+0x1c>
					shift_to_second();
     2d2:	ce 01       	movw	r24, r28
     2d4:	0e 94 07 01 	call	0x20e	; 0x20e <_ZN12gear_shifter15shift_to_secondEv>
					state = SECOND_GEAR;
     2d8:	1c 87       	std	Y+12, r17	; 0x0c
     2da:	c3 cf       	rjmp	.-122    	; 0x262 <_ZN12gear_shifter3runEv+0x1c>
				}

			} else { // in some incorrect state; print status and break
				print_status(*p_serial);
     2dc:	6e 81       	ldd	r22, Y+6	; 0x06
     2de:	7f 81       	ldd	r23, Y+7	; 0x07
     2e0:	e8 81       	ld	r30, Y
     2e2:	f9 81       	ldd	r31, Y+1	; 0x01
     2e4:	02 80       	ldd	r0, Z+2	; 0x02
     2e6:	f3 81       	ldd	r31, Z+3	; 0x03
     2e8:	e0 2d       	mov	r30, r0
     2ea:	ce 01       	movw	r24, r28
     2ec:	09 95       	icall
				break;
			}
		}
	}
}
     2ee:	df 91       	pop	r29
     2f0:	cf 91       	pop	r28
     2f2:	1f 91       	pop	r17
     2f4:	0f 91       	pop	r16
     2f6:	ff 90       	pop	r15
     2f8:	08 95       	ret

000002fa <_ZN15Adafruit_Sensor15enableAutoRangeEb>:
    // Constructor(s)
    Adafruit_Sensor() {}
    virtual ~Adafruit_Sensor() {}

    // These must be defined by the subclass
    virtual void enableAutoRange(bool enabled) { (void)enabled; /* suppress unused warning */ };
     2fa:	08 95       	ret

000002fc <_ZN8imu_taskD1Ev>:

#include "include/Adafruit_BNO055.h"
#include "include/taskbase.h"
#include "../semi_truck_data_t.h"

class imu_task : public TaskBase, public Adafruit_BNO055  {
     2fc:	08 95       	ret

000002fe <_ZThn18_N8imu_taskD1Ev>:
     2fe:	08 95       	ret

00000300 <_ZN8imu_task3runEv>:
	/// NEED TO DO SOME CALIBRATION AND SETUP FOR THE BNO055 DEVICE

}

void imu_task::run()
{
     300:	cf 92       	push	r12
     302:	df 92       	push	r13
     304:	ff 92       	push	r15
     306:	0f 93       	push	r16
     308:	1f 93       	push	r17
     30a:	cf 93       	push	r28
     30c:	df 93       	push	r29
     30e:	00 d0       	rcall	.+0      	; 0x310 <_ZN8imu_task3runEv+0x10>
     310:	cd b7       	in	r28, 0x3d	; 61
     312:	de b7       	in	r29, 0x3e	; 62
     314:	8c 01       	movw	r16, r24
		}

		else if (state == 0) {
			// todo: initialize the imu either here or in the constructor

			state = 1;
     316:	ff 24       	eor	r15, r15
     318:	f3 94       	inc	r15
	 from the IMU and write to the mega task data */
	char temp_buffer[2];

	for (;;) {
		if (state == 1) { // checked first for simple optimization as this is the primary state that the imu is in
		    readLen(BNO055_EULER_H_MSB_ADDR, temp_buffer, 2);
     31a:	6c 01       	movw	r12, r24
     31c:	82 e1       	ldi	r24, 0x12	; 18
     31e:	c8 0e       	add	r12, r24
     320:	d1 1c       	adc	r13, r1
	/* Once the device is setup to correctly read data, we can just continually read
	 from the IMU and write to the mega task data */
	char temp_buffer[2];

	for (;;) {
		if (state == 1) { // checked first for simple optimization as this is the primary state that the imu is in
     322:	d8 01       	movw	r26, r16
     324:	1c 96       	adiw	r26, 0x0c	; 12
     326:	8c 91       	ld	r24, X
     328:	81 30       	cpi	r24, 0x01	; 1
     32a:	91 f4       	brne	.+36     	; 0x350 <_ZN8imu_task3runEv+0x50>
		    readLen(BNO055_EULER_H_MSB_ADDR, temp_buffer, 2);
     32c:	22 e0       	ldi	r18, 0x02	; 2
     32e:	ae 01       	movw	r20, r28
     330:	4f 5f       	subi	r20, 0xFF	; 255
     332:	5f 4f       	sbci	r21, 0xFF	; 255
     334:	6b e1       	ldi	r22, 0x1B	; 27
     336:	c6 01       	movw	r24, r12
     338:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN15Adafruit_BNO0557readLenENS_21adafruit_bno055_reg_tEPch>
		    semi_data->imu_angle = *((int16_t *)temp_buffer); // interesting but necessary casting to get value into semi_data
     33c:	d8 01       	movw	r26, r16
     33e:	5b 96       	adiw	r26, 0x1b	; 27
     340:	ed 91       	ld	r30, X+
     342:	fc 91       	ld	r31, X
     344:	5c 97       	sbiw	r26, 0x1c	; 28
     346:	89 81       	ldd	r24, Y+1	; 0x01
     348:	9a 81       	ldd	r25, Y+2	; 0x02
     34a:	91 87       	std	Z+9, r25	; 0x09
     34c:	80 87       	std	Z+8, r24	; 0x08
     34e:	e9 cf       	rjmp	.-46     	; 0x322 <_ZN8imu_task3runEv+0x22>
		}

		else if (state == 0) {
     350:	81 11       	cpse	r24, r1
     352:	03 c0       	rjmp	.+6      	; 0x35a <_ZN8imu_task3runEv+0x5a>
			// todo: initialize the imu either here or in the constructor

			state = 1;
     354:	f8 01       	movw	r30, r16
     356:	f4 86       	std	Z+12, r15	; 0x0c
     358:	e4 cf       	rjmp	.-56     	; 0x322 <_ZN8imu_task3runEv+0x22>
		}
		else {
            print_status(*p_serial);
     35a:	d8 01       	movw	r26, r16
     35c:	16 96       	adiw	r26, 0x06	; 6
     35e:	6d 91       	ld	r22, X+
     360:	7c 91       	ld	r23, X
     362:	17 97       	sbiw	r26, 0x07	; 7
     364:	ed 91       	ld	r30, X+
     366:	fc 91       	ld	r31, X
     368:	02 80       	ldd	r0, Z+2	; 0x02
     36a:	f3 81       	ldd	r31, Z+3	; 0x03
     36c:	e0 2d       	mov	r30, r0
     36e:	c8 01       	movw	r24, r16
     370:	09 95       	icall
            break;
		}

	}

}
     372:	0f 90       	pop	r0
     374:	0f 90       	pop	r0
     376:	df 91       	pop	r29
     378:	cf 91       	pop	r28
     37a:	1f 91       	pop	r17
     37c:	0f 91       	pop	r16
     37e:	ff 90       	pop	r15
     380:	df 90       	pop	r13
     382:	cf 90       	pop	r12
     384:	08 95       	ret

00000386 <_ZN8imu_taskD0Ev>:
     386:	0e 94 dd 04 	call	0x9ba	; 0x9ba <_ZdlPv>
     38a:	08 95       	ret

0000038c <_ZThn18_N8imu_taskD0Ev>:
     38c:	42 97       	sbiw	r24, 0x12	; 18
     38e:	0e 94 dd 04 	call	0x9ba	; 0x9ba <_ZdlPv>
     392:	08 95       	ret

00000394 <_ZN8imu_taskC1EPKchjP8emstreammhP17semi_truck_data_t>:
//

#include "imu_task.h"
#include "../semi_truck_data_t.h"

imu_task::imu_task(const char *a_name, unsigned char a_priority, size_t a_stack_size, emstream *p_ser_dev, uint32_t sensorID,
     394:	6f 92       	push	r6
     396:	7f 92       	push	r7
     398:	8f 92       	push	r8
     39a:	9f 92       	push	r9
     39c:	af 92       	push	r10
     39e:	cf 92       	push	r12
     3a0:	df 92       	push	r13
     3a2:	ef 92       	push	r14
     3a4:	ff 92       	push	r15
     3a6:	0f 93       	push	r16
     3a8:	1f 93       	push	r17
     3aa:	cf 93       	push	r28
     3ac:	df 93       	push	r29
     3ae:	cd b7       	in	r28, 0x3d	; 61
     3b0:	de b7       	in	r29, 0x3e	; 62
     3b2:	3c 01       	movw	r6, r24
                   uint8_t address, semi_truck_data_t *semi_data_in)
		: TaskBase(a_name, a_priority, a_stack_size, p_ser_dev),
		Adafruit_BNO055(sensorID, address)
     3b4:	0e 94 b2 06 	call	0xd64	; 0xd64 <_ZN8TaskBaseC1EPKchjP8emstream>
     3b8:	2a 2d       	mov	r18, r10
     3ba:	b7 01       	movw	r22, r14
     3bc:	a6 01       	movw	r20, r12
     3be:	c3 01       	movw	r24, r6
     3c0:	42 96       	adiw	r24, 0x12	; 18
     3c2:	0e 94 a9 02 	call	0x552	; 0x552 <_ZN15Adafruit_BNO055C1Elh>
     3c6:	8a e1       	ldi	r24, 0x1A	; 26
     3c8:	91 e0       	ldi	r25, 0x01	; 1
     3ca:	f3 01       	movw	r30, r6
     3cc:	91 83       	std	Z+1, r25	; 0x01
     3ce:	80 83       	st	Z, r24
     3d0:	86 e2       	ldi	r24, 0x26	; 38
     3d2:	91 e0       	ldi	r25, 0x01	; 1
     3d4:	93 8b       	std	Z+19, r25	; 0x13
     3d6:	82 8b       	std	Z+18, r24	; 0x12
{
    semi_data = semi_data_in;
     3d8:	94 8e       	std	Z+28, r9	; 0x1c
     3da:	83 8e       	std	Z+27, r8	; 0x1b
    state = 0;
     3dc:	14 86       	std	Z+12, r1	; 0x0c
	/// NEED TO DO SOME CALIBRATION AND SETUP FOR THE BNO055 DEVICE

}
     3de:	df 91       	pop	r29
     3e0:	cf 91       	pop	r28
     3e2:	1f 91       	pop	r17
     3e4:	0f 91       	pop	r16
     3e6:	ff 90       	pop	r15
     3e8:	ef 90       	pop	r14
     3ea:	df 90       	pop	r13
     3ec:	cf 90       	pop	r12
     3ee:	af 90       	pop	r10
     3f0:	9f 90       	pop	r9
     3f2:	8f 90       	pop	r8
     3f4:	7f 90       	pop	r7
     3f6:	6f 90       	pop	r6
     3f8:	08 95       	ret

000003fa <_ZN12motor_driver3runEv>:
{
    semi_data = semi_data_in;
}

void motor_driver::run()
{
     3fa:	08 95       	ret

000003fc <_ZN12motor_driverC1EPKchjP8emstreamP17semi_truck_data_t>:
//

#include "motor_driver.h"
#include "../semi_truck_data_t.h"

motor_driver::motor_driver(const char *a_name, unsigned char a_priority, size_t a_stack_size, emstream *p_ser_dev,
     3fc:	ef 92       	push	r14
     3fe:	ff 92       	push	r15
     400:	0f 93       	push	r16
     402:	1f 93       	push	r17
     404:	cf 93       	push	r28
     406:	df 93       	push	r29
     408:	ec 01       	movw	r28, r24
                           semi_truck_data_t *semi_data_in)
        : TaskBase(a_name, a_priority, a_stack_size, p_ser_dev)
     40a:	0e 94 b2 06 	call	0xd64	; 0xd64 <_ZN8TaskBaseC1EPKchjP8emstream>
     40e:	84 e3       	ldi	r24, 0x34	; 52
     410:	91 e0       	ldi	r25, 0x01	; 1
     412:	99 83       	std	Y+1, r25	; 0x01
     414:	88 83       	st	Y, r24
{
    semi_data = semi_data_in;
     416:	fb 8a       	std	Y+19, r15	; 0x13
     418:	ea 8a       	std	Y+18, r14	; 0x12
}
     41a:	df 91       	pop	r29
     41c:	cf 91       	pop	r28
     41e:	1f 91       	pop	r17
     420:	0f 91       	pop	r16
     422:	ff 90       	pop	r15
     424:	ef 90       	pop	r14
     426:	08 95       	ret

00000428 <_ZN5servoC1Ev>:
#include "servo.h"

servo::servo()
     428:	08 95       	ret

0000042a <_ZN5servo5writeEi>:

}


void servo::write(int value)
{
     42a:	08 95       	ret

0000042c <_ZN11steer_servo3runEv>:
    semi_data = semi_data_in;
    write(FORWARDS); // want the semi-truck to start facing forwards
}

void steer_servo::run()
{
     42c:	ec 01       	movw	r28, r24
	for (;;) {
	    write(semi_data->steer_output);
     42e:	ea 89       	ldd	r30, Y+18	; 0x12
     430:	fb 89       	ldd	r31, Y+19	; 0x13
     432:	64 81       	ldd	r22, Z+4	; 0x04
     434:	75 81       	ldd	r23, Z+5	; 0x05
     436:	ce 01       	movw	r24, r28
     438:	0e 94 15 02 	call	0x42a	; 0x42a <_ZN5servo5writeEi>
     43c:	f8 cf       	rjmp	.-16     	; 0x42e <_ZN11steer_servo3runEv+0x2>

0000043e <_ZN11steer_servoC1EPKchjP8emstreamP17semi_truck_data_t>:
#include "steer_servo.h"
#include "../semi_truck_data_t.h"

#define FORWARDS 0

steer_servo::steer_servo(const char *a_name, unsigned char a_priority, size_t a_stack_size, emstream *p_ser_dev,
     43e:	9f 92       	push	r9
     440:	af 92       	push	r10
     442:	bf 92       	push	r11
     444:	cf 92       	push	r12
     446:	df 92       	push	r13
     448:	ef 92       	push	r14
     44a:	ff 92       	push	r15
     44c:	0f 93       	push	r16
     44e:	1f 93       	push	r17
     450:	cf 93       	push	r28
     452:	df 93       	push	r29
     454:	ec 01       	movw	r28, r24
     456:	6b 01       	movw	r12, r22
     458:	94 2e       	mov	r9, r20
     45a:	59 01       	movw	r10, r18
						 semi_truck_data_t *semi_data_in)
		:TaskBase::TaskBase(a_name, a_priority, a_stack_size, p_ser_dev)
     45c:	0e 94 14 02 	call	0x428	; 0x428 <_ZN5servoC1Ev>
     460:	95 01       	movw	r18, r10
     462:	49 2d       	mov	r20, r9
     464:	b6 01       	movw	r22, r12
     466:	ce 01       	movw	r24, r28
     468:	0e 94 b2 06 	call	0xd64	; 0xd64 <_ZN8TaskBaseC1EPKchjP8emstream>
     46c:	8c e3       	ldi	r24, 0x3C	; 60
     46e:	91 e0       	ldi	r25, 0x01	; 1
     470:	99 83       	std	Y+1, r25	; 0x01
     472:	88 83       	st	Y, r24
{
    semi_data = semi_data_in;
     474:	fb 8a       	std	Y+19, r15	; 0x13
     476:	ea 8a       	std	Y+18, r14	; 0x12
    write(FORWARDS); // want the semi-truck to start facing forwards
     478:	60 e0       	ldi	r22, 0x00	; 0
     47a:	70 e0       	ldi	r23, 0x00	; 0
     47c:	ce 01       	movw	r24, r28
     47e:	0e 94 15 02 	call	0x42a	; 0x42a <_ZN5servo5writeEi>
}
     482:	df 91       	pop	r29
     484:	cf 91       	pop	r28
     486:	1f 91       	pop	r17
     488:	0f 91       	pop	r16
     48a:	ff 90       	pop	r15
     48c:	ef 90       	pop	r14
     48e:	df 90       	pop	r13
     490:	cf 90       	pop	r12
     492:	bf 90       	pop	r11
     494:	af 90       	pop	r10
     496:	9f 90       	pop	r9
     498:	08 95       	ret

0000049a <_ZN11wheel_speed3runEv>:
{
	semi_data = semi_data_in;
}

void wheel_speed::run()
{
     49a:	08 95       	ret

0000049c <_ZN11wheel_speedC1EPKchjP8emstreamP17semi_truck_data_t>:
//

#include "wheel_speed.h"
#include "../semi_truck_data_t.h"

wheel_speed::wheel_speed(const char *a_name, unsigned char a_priority, size_t a_stack_size, emstream *p_ser_dev,
     49c:	ef 92       	push	r14
     49e:	ff 92       	push	r15
     4a0:	0f 93       	push	r16
     4a2:	1f 93       	push	r17
     4a4:	cf 93       	push	r28
     4a6:	df 93       	push	r29
     4a8:	ec 01       	movw	r28, r24
						 semi_truck_data_t *semi_data_in)
		: TaskBase::TaskBase(a_name, a_priority, a_stack_size, p_ser_dev)
     4aa:	0e 94 b2 06 	call	0xd64	; 0xd64 <_ZN8TaskBaseC1EPKchjP8emstream>
     4ae:	84 e4       	ldi	r24, 0x44	; 68
     4b0:	91 e0       	ldi	r25, 0x01	; 1
     4b2:	99 83       	std	Y+1, r25	; 0x01
     4b4:	88 83       	st	Y, r24
{
	semi_data = semi_data_in;
     4b6:	fb 8a       	std	Y+19, r15	; 0x13
     4b8:	ea 8a       	std	Y+18, r14	; 0x12
}
     4ba:	df 91       	pop	r29
     4bc:	cf 91       	pop	r28
     4be:	1f 91       	pop	r17
     4c0:	0f 91       	pop	r16
     4c2:	ff 90       	pop	r15
     4c4:	ef 90       	pop	r14
     4c6:	08 95       	ret

000004c8 <_ZN15Adafruit_BNO055D1Ev>:
    #endif

    return value;
    */
    return 0;
}
     4c8:	08 95       	ret

000004ca <_ZN15Adafruit_BNO0559getSensorEP8sensor_t>:
     4ca:	0f 93       	push	r16
     4cc:	1f 93       	push	r17
     4ce:	cf 93       	push	r28
     4d0:	df 93       	push	r29
     4d2:	8c 01       	movw	r16, r24
     4d4:	eb 01       	movw	r28, r22
     4d6:	88 e2       	ldi	r24, 0x28	; 40
     4d8:	fb 01       	movw	r30, r22
     4da:	11 92       	st	Z+, r1
     4dc:	8a 95       	dec	r24
     4de:	e9 f7       	brne	.-6      	; 0x4da <_ZN15Adafruit_BNO0559getSensorEP8sensor_t+0x10>
     4e0:	4b e0       	ldi	r20, 0x0B	; 11
     4e2:	50 e0       	ldi	r21, 0x00	; 0
     4e4:	68 e4       	ldi	r22, 0x48	; 72
     4e6:	71 e0       	ldi	r23, 0x01	; 1
     4e8:	ce 01       	movw	r24, r28
     4ea:	0e 94 41 0b 	call	0x1682	; 0x1682 <strncpy>
     4ee:	1b 86       	std	Y+11, r1	; 0x0b
     4f0:	81 e0       	ldi	r24, 0x01	; 1
     4f2:	90 e0       	ldi	r25, 0x00	; 0
     4f4:	a0 e0       	ldi	r26, 0x00	; 0
     4f6:	b0 e0       	ldi	r27, 0x00	; 0
     4f8:	8c 87       	std	Y+12, r24	; 0x0c
     4fa:	9d 87       	std	Y+13, r25	; 0x0d
     4fc:	ae 87       	std	Y+14, r26	; 0x0e
     4fe:	bf 87       	std	Y+15, r27	; 0x0f
     500:	f8 01       	movw	r30, r16
     502:	84 81       	ldd	r24, Z+4	; 0x04
     504:	95 81       	ldd	r25, Z+5	; 0x05
     506:	a6 81       	ldd	r26, Z+6	; 0x06
     508:	b7 81       	ldd	r27, Z+7	; 0x07
     50a:	88 8b       	std	Y+16, r24	; 0x10
     50c:	99 8b       	std	Y+17, r25	; 0x11
     50e:	aa 8b       	std	Y+18, r26	; 0x12
     510:	bb 8b       	std	Y+19, r27	; 0x13
     512:	83 e0       	ldi	r24, 0x03	; 3
     514:	90 e0       	ldi	r25, 0x00	; 0
     516:	a0 e0       	ldi	r26, 0x00	; 0
     518:	b0 e0       	ldi	r27, 0x00	; 0
     51a:	8c 8b       	std	Y+20, r24	; 0x14
     51c:	9d 8b       	std	Y+21, r25	; 0x15
     51e:	ae 8b       	std	Y+22, r26	; 0x16
     520:	bf 8b       	std	Y+23, r27	; 0x17
     522:	18 8e       	std	Y+24, r1	; 0x18
     524:	19 8e       	std	Y+25, r1	; 0x19
     526:	1a 8e       	std	Y+26, r1	; 0x1a
     528:	1b 8e       	std	Y+27, r1	; 0x1b
     52a:	1c 8e       	std	Y+28, r1	; 0x1c
     52c:	1d 8e       	std	Y+29, r1	; 0x1d
     52e:	1e 8e       	std	Y+30, r1	; 0x1e
     530:	1f 8e       	std	Y+31, r1	; 0x1f
     532:	8a e0       	ldi	r24, 0x0A	; 10
     534:	97 ed       	ldi	r25, 0xD7	; 215
     536:	a3 e2       	ldi	r26, 0x23	; 35
     538:	bc e3       	ldi	r27, 0x3C	; 60
     53a:	88 a3       	std	Y+32, r24	; 0x20
     53c:	99 a3       	std	Y+33, r25	; 0x21
     53e:	aa a3       	std	Y+34, r26	; 0x22
     540:	bb a3       	std	Y+35, r27	; 0x23
     542:	df 91       	pop	r29
     544:	cf 91       	pop	r28
     546:	1f 91       	pop	r17
     548:	0f 91       	pop	r16
     54a:	08 95       	ret

0000054c <_ZN15Adafruit_BNO055D0Ev>:
     54c:	0e 94 dd 04 	call	0x9ba	; 0x9ba <_ZdlPv>
     550:	08 95       	ret

00000552 <_ZN15Adafruit_BNO055C1Elh>:
     552:	fc 01       	movw	r30, r24
     554:	83 e5       	ldi	r24, 0x53	; 83
     556:	91 e0       	ldi	r25, 0x01	; 1
     558:	91 83       	std	Z+1, r25	; 0x01
     55a:	80 83       	st	Z, r24
     55c:	44 83       	std	Z+4, r20	; 0x04
     55e:	55 83       	std	Z+5, r21	; 0x05
     560:	66 83       	std	Z+6, r22	; 0x06
     562:	77 83       	std	Z+7, r23	; 0x07
     564:	23 83       	std	Z+3, r18	; 0x03
     566:	08 95       	ret

00000568 <_ZN15Adafruit_BNO0559getVectorENS_22adafruit_vector_type_tE>:
     568:	cf 93       	push	r28
     56a:	df 93       	push	r29
     56c:	00 d0       	rcall	.+0      	; 0x56e <_ZN15Adafruit_BNO0559getVectorENS_22adafruit_vector_type_tE+0x6>
     56e:	00 d0       	rcall	.+0      	; 0x570 <_ZN15Adafruit_BNO0559getVectorENS_22adafruit_vector_type_tE+0x8>
     570:	00 d0       	rcall	.+0      	; 0x572 <_ZN15Adafruit_BNO0559getVectorENS_22adafruit_vector_type_tE+0xa>
     572:	cd b7       	in	r28, 0x3d	; 61
     574:	de b7       	in	r29, 0x3e	; 62
     576:	2c e0       	ldi	r18, 0x0C	; 12
     578:	dc 01       	movw	r26, r24
     57a:	1d 92       	st	X+, r1
     57c:	2a 95       	dec	r18
     57e:	e9 f7       	brne	.-6      	; 0x57a <_ZN15Adafruit_BNO0559getVectorENS_22adafruit_vector_type_tE+0x12>
     580:	fe 01       	movw	r30, r28
     582:	31 96       	adiw	r30, 0x01	; 1
     584:	26 e0       	ldi	r18, 0x06	; 6
     586:	df 01       	movw	r26, r30
     588:	1d 92       	st	X+, r1
     58a:	2a 95       	dec	r18
     58c:	e9 f7       	brne	.-6      	; 0x588 <_ZN15Adafruit_BNO0559getVectorENS_22adafruit_vector_type_tE+0x20>
     58e:	44 31       	cpi	r20, 0x14	; 20
     590:	d9 f0       	breq	.+54     	; 0x5c8 <_ZN15Adafruit_BNO0559getVectorENS_22adafruit_vector_type_tE+0x60>
     592:	28 f4       	brcc	.+10     	; 0x59e <_ZN15Adafruit_BNO0559getVectorENS_22adafruit_vector_type_tE+0x36>
     594:	48 30       	cpi	r20, 0x08	; 8
     596:	b9 f1       	breq	.+110    	; 0x606 <_ZN15Adafruit_BNO0559getVectorENS_22adafruit_vector_type_tE+0x9e>
     598:	4e 30       	cpi	r20, 0x0E	; 14
     59a:	41 f0       	breq	.+16     	; 0x5ac <_ZN15Adafruit_BNO0559getVectorENS_22adafruit_vector_type_tE+0x44>
     59c:	41 c0       	rjmp	.+130    	; 0x620 <_ZN15Adafruit_BNO0559getVectorENS_22adafruit_vector_type_tE+0xb8>
     59e:	48 32       	cpi	r20, 0x28	; 40
     5a0:	91 f1       	breq	.+100    	; 0x606 <_ZN15Adafruit_BNO0559getVectorENS_22adafruit_vector_type_tE+0x9e>
     5a2:	4e 32       	cpi	r20, 0x2E	; 46
     5a4:	81 f1       	breq	.+96     	; 0x606 <_ZN15Adafruit_BNO0559getVectorENS_22adafruit_vector_type_tE+0x9e>
     5a6:	4a 31       	cpi	r20, 0x1A	; 26
     5a8:	e1 f0       	breq	.+56     	; 0x5e2 <_ZN15Adafruit_BNO0559getVectorENS_22adafruit_vector_type_tE+0x7a>
     5aa:	3a c0       	rjmp	.+116    	; 0x620 <_ZN15Adafruit_BNO0559getVectorENS_22adafruit_vector_type_tE+0xb8>
     5ac:	fc 01       	movw	r30, r24
     5ae:	10 82       	st	Z, r1
     5b0:	11 82       	std	Z+1, r1	; 0x01
     5b2:	12 82       	std	Z+2, r1	; 0x02
     5b4:	13 82       	std	Z+3, r1	; 0x03
     5b6:	14 82       	std	Z+4, r1	; 0x04
     5b8:	15 82       	std	Z+5, r1	; 0x05
     5ba:	16 82       	std	Z+6, r1	; 0x06
     5bc:	17 82       	std	Z+7, r1	; 0x07
     5be:	10 86       	std	Z+8, r1	; 0x08
     5c0:	11 86       	std	Z+9, r1	; 0x09
     5c2:	12 86       	std	Z+10, r1	; 0x0a
     5c4:	13 86       	std	Z+11, r1	; 0x0b
     5c6:	2c c0       	rjmp	.+88     	; 0x620 <_ZN15Adafruit_BNO0559getVectorENS_22adafruit_vector_type_tE+0xb8>
     5c8:	dc 01       	movw	r26, r24
     5ca:	14 96       	adiw	r26, 0x04	; 4
     5cc:	1d 92       	st	X+, r1
     5ce:	1d 92       	st	X+, r1
     5d0:	1d 92       	st	X+, r1
     5d2:	1c 92       	st	X, r1
     5d4:	17 97       	sbiw	r26, 0x07	; 7
     5d6:	fc 01       	movw	r30, r24
     5d8:	10 86       	std	Z+8, r1	; 0x08
     5da:	11 86       	std	Z+9, r1	; 0x09
     5dc:	12 86       	std	Z+10, r1	; 0x0a
     5de:	13 86       	std	Z+11, r1	; 0x0b
     5e0:	1f c0       	rjmp	.+62     	; 0x620 <_ZN15Adafruit_BNO0559getVectorENS_22adafruit_vector_type_tE+0xb8>
     5e2:	dc 01       	movw	r26, r24
     5e4:	1d 92       	st	X+, r1
     5e6:	1d 92       	st	X+, r1
     5e8:	1d 92       	st	X+, r1
     5ea:	1c 92       	st	X, r1
     5ec:	13 97       	sbiw	r26, 0x03	; 3
     5ee:	fc 01       	movw	r30, r24
     5f0:	14 82       	std	Z+4, r1	; 0x04
     5f2:	15 82       	std	Z+5, r1	; 0x05
     5f4:	16 82       	std	Z+6, r1	; 0x06
     5f6:	17 82       	std	Z+7, r1	; 0x07
     5f8:	18 96       	adiw	r26, 0x08	; 8
     5fa:	1d 92       	st	X+, r1
     5fc:	1d 92       	st	X+, r1
     5fe:	1d 92       	st	X+, r1
     600:	1c 92       	st	X, r1
     602:	1b 97       	sbiw	r26, 0x0b	; 11
     604:	0d c0       	rjmp	.+26     	; 0x620 <_ZN15Adafruit_BNO0559getVectorENS_22adafruit_vector_type_tE+0xb8>
     606:	fc 01       	movw	r30, r24
     608:	10 82       	st	Z, r1
     60a:	11 82       	std	Z+1, r1	; 0x01
     60c:	12 82       	std	Z+2, r1	; 0x02
     60e:	13 82       	std	Z+3, r1	; 0x03
     610:	14 82       	std	Z+4, r1	; 0x04
     612:	15 82       	std	Z+5, r1	; 0x05
     614:	16 82       	std	Z+6, r1	; 0x06
     616:	17 82       	std	Z+7, r1	; 0x07
     618:	10 86       	std	Z+8, r1	; 0x08
     61a:	11 86       	std	Z+9, r1	; 0x09
     61c:	12 86       	std	Z+10, r1	; 0x0a
     61e:	13 86       	std	Z+11, r1	; 0x0b
     620:	26 96       	adiw	r28, 0x06	; 6
     622:	0f b6       	in	r0, 0x3f	; 63
     624:	f8 94       	cli
     626:	de bf       	out	0x3e, r29	; 62
     628:	0f be       	out	0x3f, r0	; 63
     62a:	cd bf       	out	0x3d, r28	; 61
     62c:	df 91       	pop	r29
     62e:	cf 91       	pop	r28
     630:	08 95       	ret

00000632 <_ZN15Adafruit_BNO0558getEventEP15sensors_event_t>:
     632:	0f 93       	push	r16
     634:	1f 93       	push	r17
     636:	cf 93       	push	r28
     638:	df 93       	push	r29
     63a:	cd b7       	in	r28, 0x3d	; 61
     63c:	de b7       	in	r29, 0x3e	; 62
     63e:	2c 97       	sbiw	r28, 0x0c	; 12
     640:	0f b6       	in	r0, 0x3f	; 63
     642:	f8 94       	cli
     644:	de bf       	out	0x3e, r29	; 62
     646:	0f be       	out	0x3f, r0	; 63
     648:	cd bf       	out	0x3d, r28	; 61
     64a:	8b 01       	movw	r16, r22
     64c:	24 e2       	ldi	r18, 0x24	; 36
     64e:	fb 01       	movw	r30, r22
     650:	11 92       	st	Z+, r1
     652:	2a 95       	dec	r18
     654:	e9 f7       	brne	.-6      	; 0x650 <_ZN15Adafruit_BNO0558getEventEP15sensors_event_t+0x1e>
     656:	44 e2       	ldi	r20, 0x24	; 36
     658:	50 e0       	ldi	r21, 0x00	; 0
     65a:	60 e0       	ldi	r22, 0x00	; 0
     65c:	70 e0       	ldi	r23, 0x00	; 0
     65e:	f8 01       	movw	r30, r16
     660:	40 83       	st	Z, r20
     662:	51 83       	std	Z+1, r21	; 0x01
     664:	62 83       	std	Z+2, r22	; 0x02
     666:	73 83       	std	Z+3, r23	; 0x03
     668:	fc 01       	movw	r30, r24
     66a:	44 81       	ldd	r20, Z+4	; 0x04
     66c:	55 81       	ldd	r21, Z+5	; 0x05
     66e:	66 81       	ldd	r22, Z+6	; 0x06
     670:	77 81       	ldd	r23, Z+7	; 0x07
     672:	f8 01       	movw	r30, r16
     674:	44 83       	std	Z+4, r20	; 0x04
     676:	55 83       	std	Z+5, r21	; 0x05
     678:	66 83       	std	Z+6, r22	; 0x06
     67a:	77 83       	std	Z+7, r23	; 0x07
     67c:	43 e0       	ldi	r20, 0x03	; 3
     67e:	50 e0       	ldi	r21, 0x00	; 0
     680:	60 e0       	ldi	r22, 0x00	; 0
     682:	70 e0       	ldi	r23, 0x00	; 0
     684:	40 87       	std	Z+8, r20	; 0x08
     686:	51 87       	std	Z+9, r21	; 0x09
     688:	62 87       	std	Z+10, r22	; 0x0a
     68a:	73 87       	std	Z+11, r23	; 0x0b
     68c:	4a e1       	ldi	r20, 0x1A	; 26
     68e:	bc 01       	movw	r22, r24
     690:	ce 01       	movw	r24, r28
     692:	01 96       	adiw	r24, 0x01	; 1
     694:	0e 94 b4 02 	call	0x568	; 0x568 <_ZN15Adafruit_BNO0559getVectorENS_22adafruit_vector_type_tE>
     698:	89 81       	ldd	r24, Y+1	; 0x01
     69a:	9a 81       	ldd	r25, Y+2	; 0x02
     69c:	ab 81       	ldd	r26, Y+3	; 0x03
     69e:	bc 81       	ldd	r27, Y+4	; 0x04
     6a0:	f8 01       	movw	r30, r16
     6a2:	84 8b       	std	Z+20, r24	; 0x14
     6a4:	95 8b       	std	Z+21, r25	; 0x15
     6a6:	a6 8b       	std	Z+22, r26	; 0x16
     6a8:	b7 8b       	std	Z+23, r27	; 0x17
     6aa:	8d 81       	ldd	r24, Y+5	; 0x05
     6ac:	9e 81       	ldd	r25, Y+6	; 0x06
     6ae:	af 81       	ldd	r26, Y+7	; 0x07
     6b0:	b8 85       	ldd	r27, Y+8	; 0x08
     6b2:	80 8f       	std	Z+24, r24	; 0x18
     6b4:	91 8f       	std	Z+25, r25	; 0x19
     6b6:	a2 8f       	std	Z+26, r26	; 0x1a
     6b8:	b3 8f       	std	Z+27, r27	; 0x1b
     6ba:	89 85       	ldd	r24, Y+9	; 0x09
     6bc:	9a 85       	ldd	r25, Y+10	; 0x0a
     6be:	ab 85       	ldd	r26, Y+11	; 0x0b
     6c0:	bc 85       	ldd	r27, Y+12	; 0x0c
     6c2:	84 8f       	std	Z+28, r24	; 0x1c
     6c4:	95 8f       	std	Z+29, r25	; 0x1d
     6c6:	a6 8f       	std	Z+30, r26	; 0x1e
     6c8:	b7 8f       	std	Z+31, r27	; 0x1f
     6ca:	81 e0       	ldi	r24, 0x01	; 1
     6cc:	2c 96       	adiw	r28, 0x0c	; 12
     6ce:	0f b6       	in	r0, 0x3f	; 63
     6d0:	f8 94       	cli
     6d2:	de bf       	out	0x3e, r29	; 62
     6d4:	0f be       	out	0x3f, r0	; 63
     6d6:	cd bf       	out	0x3d, r28	; 61
     6d8:	df 91       	pop	r29
     6da:	cf 91       	pop	r28
     6dc:	1f 91       	pop	r17
     6de:	0f 91       	pop	r16
     6e0:	08 95       	ret

000006e2 <_ZN15Adafruit_BNO0557readLenENS_21adafruit_bno055_reg_tEPch>:
    }
     */

    /* ToDo: Check for errors! */
    return true;
}
     6e2:	81 e0       	ldi	r24, 0x01	; 1
     6e4:	08 95       	ret

000006e6 <_ZN8emstream4putsEPKc>:
 *           character, \c '\0') is reached.
 *  @param   p_string A pointer to the string which is to be printed
 */

void emstream::puts (const char* p_string)
{
     6e6:	08 95       	ret

000006e8 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     6e8:	0f 93       	push	r16
     6ea:	1f 93       	push	r17
     6ec:	cf 93       	push	r28
     6ee:	df 93       	push	r29
     6f0:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
     6f2:	0e 94 a3 08 	call	0x1146	; 0x1146 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
     6f6:	80 91 9e 01 	lds	r24, 0x019E	; 0x80019e <__data_end>
     6fa:	81 11       	cpse	r24, r1
     6fc:	1d c0       	rjmp	.+58     	; 0x738 <pvPortMalloc+0x50>
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     6fe:	e3 ea       	ldi	r30, 0xA3	; 163
     700:	f1 e0       	ldi	r31, 0x01	; 1
     702:	88 ea       	ldi	r24, 0xA8	; 168
     704:	91 e0       	ldi	r25, 0x01	; 1
     706:	91 83       	std	Z+1, r25	; 0x01
     708:	80 83       	st	Z, r24
	xStart.xBlockSize = ( size_t ) 0;
     70a:	13 82       	std	Z+3, r1	; 0x03
     70c:	12 82       	std	Z+2, r1	; 0x02

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
     70e:	ef e9       	ldi	r30, 0x9F	; 159
     710:	f1 e0       	ldi	r31, 0x01	; 1
     712:	87 e7       	ldi	r24, 0x77	; 119
     714:	9a e0       	ldi	r25, 0x0A	; 10
     716:	93 83       	std	Z+3, r25	; 0x03
     718:	82 83       	std	Z+2, r24	; 0x02
	xEnd.pxNextFreeBlock = NULL;
     71a:	11 82       	std	Z+1, r1	; 0x01
     71c:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
     71e:	a7 ea       	ldi	r26, 0xA7	; 167
     720:	b1 e0       	ldi	r27, 0x01	; 1
     722:	14 96       	adiw	r26, 0x04	; 4
     724:	9c 93       	st	X, r25
     726:	8e 93       	st	-X, r24
     728:	13 97       	sbiw	r26, 0x03	; 3
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
     72a:	12 96       	adiw	r26, 0x02	; 2
     72c:	fc 93       	st	X, r31
     72e:	ee 93       	st	-X, r30
     730:	11 97       	sbiw	r26, 0x01	; 1
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
		{
			prvHeapInit();
			xHeapHasBeenInitialised = pdTRUE;
     732:	81 e0       	ldi	r24, 0x01	; 1
     734:	80 93 9e 01 	sts	0x019E, r24	; 0x80019e <__data_end>
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
     738:	20 97       	sbiw	r28, 0x00	; 0
     73a:	09 f4       	brne	.+2      	; 0x73e <pvPortMalloc+0x56>
     73c:	5f c0       	rjmp	.+190    	; 0x7fc <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
     73e:	9e 01       	movw	r18, r28
     740:	2c 5f       	subi	r18, 0xFC	; 252
     742:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
     744:	23 96       	adiw	r28, 0x03	; 3
     746:	c6 37       	cpi	r28, 0x76	; 118
     748:	da 40       	sbci	r29, 0x0A	; 10
     74a:	08 f0       	brcs	.+2      	; 0x74e <pvPortMalloc+0x66>
     74c:	5a c0       	rjmp	.+180    	; 0x802 <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
     74e:	e0 91 a3 01 	lds	r30, 0x01A3	; 0x8001a3 <xStart>
     752:	f0 91 a4 01 	lds	r31, 0x01A4	; 0x8001a4 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     756:	a3 ea       	ldi	r26, 0xA3	; 163
     758:	b1 e0       	ldi	r27, 0x01	; 1
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     75a:	02 c0       	rjmp	.+4      	; 0x760 <pvPortMalloc+0x78>
     75c:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
     75e:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     760:	82 81       	ldd	r24, Z+2	; 0x02
     762:	93 81       	ldd	r25, Z+3	; 0x03
     764:	82 17       	cp	r24, r18
     766:	93 07       	cpc	r25, r19
     768:	20 f4       	brcc	.+8      	; 0x772 <pvPortMalloc+0x8a>
     76a:	80 81       	ld	r24, Z
     76c:	91 81       	ldd	r25, Z+1	; 0x01
     76e:	00 97       	sbiw	r24, 0x00	; 0
     770:	a9 f7       	brne	.-22     	; 0x75c <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     772:	c1 e0       	ldi	r28, 0x01	; 1
     774:	ef 39       	cpi	r30, 0x9F	; 159
     776:	fc 07       	cpc	r31, r28
     778:	09 f4       	brne	.+2      	; 0x77c <pvPortMalloc+0x94>
     77a:	46 c0       	rjmp	.+140    	; 0x808 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     77c:	cd 91       	ld	r28, X+
     77e:	dc 91       	ld	r29, X
     780:	11 97       	sbiw	r26, 0x01	; 1
     782:	8e 01       	movw	r16, r28
     784:	0c 5f       	subi	r16, 0xFC	; 252
     786:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     788:	80 81       	ld	r24, Z
     78a:	91 81       	ldd	r25, Z+1	; 0x01
     78c:	8d 93       	st	X+, r24
     78e:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     790:	82 81       	ldd	r24, Z+2	; 0x02
     792:	93 81       	ldd	r25, Z+3	; 0x03
     794:	82 1b       	sub	r24, r18
     796:	93 0b       	sbc	r25, r19
     798:	89 30       	cpi	r24, 0x09	; 9
     79a:	91 05       	cpc	r25, r1
     79c:	10 f1       	brcs	.+68     	; 0x7e2 <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     79e:	bf 01       	movw	r22, r30
     7a0:	62 0f       	add	r22, r18
     7a2:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     7a4:	db 01       	movw	r26, r22
     7a6:	13 96       	adiw	r26, 0x03	; 3
     7a8:	9c 93       	st	X, r25
     7aa:	8e 93       	st	-X, r24
     7ac:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
     7ae:	33 83       	std	Z+3, r19	; 0x03
     7b0:	22 83       	std	Z+2, r18	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     7b2:	12 96       	adiw	r26, 0x02	; 2
     7b4:	4d 91       	ld	r20, X+
     7b6:	5c 91       	ld	r21, X
     7b8:	13 97       	sbiw	r26, 0x03	; 3
     7ba:	83 ea       	ldi	r24, 0xA3	; 163
     7bc:	91 e0       	ldi	r25, 0x01	; 1
     7be:	01 c0       	rjmp	.+2      	; 0x7c2 <pvPortMalloc+0xda>
     7c0:	cd 01       	movw	r24, r26
     7c2:	ec 01       	movw	r28, r24
     7c4:	a8 81       	ld	r26, Y
     7c6:	b9 81       	ldd	r27, Y+1	; 0x01
     7c8:	12 96       	adiw	r26, 0x02	; 2
     7ca:	2d 91       	ld	r18, X+
     7cc:	3c 91       	ld	r19, X
     7ce:	13 97       	sbiw	r26, 0x03	; 3
     7d0:	24 17       	cp	r18, r20
     7d2:	35 07       	cpc	r19, r21
     7d4:	a8 f3       	brcs	.-22     	; 0x7c0 <pvPortMalloc+0xd8>
     7d6:	eb 01       	movw	r28, r22
     7d8:	b9 83       	std	Y+1, r27	; 0x01
     7da:	a8 83       	st	Y, r26
     7dc:	dc 01       	movw	r26, r24
     7de:	6d 93       	st	X+, r22
     7e0:	7c 93       	st	X, r23
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
     7e2:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     7e6:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <__data_start+0x1>
     7ea:	22 81       	ldd	r18, Z+2	; 0x02
     7ec:	33 81       	ldd	r19, Z+3	; 0x03
     7ee:	82 1b       	sub	r24, r18
     7f0:	93 0b       	sbc	r25, r19
     7f2:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
     7f6:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
     7fa:	08 c0       	rjmp	.+16     	; 0x80c <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
     7fc:	00 e0       	ldi	r16, 0x00	; 0
     7fe:	10 e0       	ldi	r17, 0x00	; 0
     800:	05 c0       	rjmp	.+10     	; 0x80c <pvPortMalloc+0x124>
     802:	00 e0       	ldi	r16, 0x00	; 0
     804:	10 e0       	ldi	r17, 0x00	; 0
     806:	02 c0       	rjmp	.+4      	; 0x80c <pvPortMalloc+0x124>
     808:	00 e0       	ldi	r16, 0x00	; 0
     80a:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     80c:	0e 94 b4 09 	call	0x1368	; 0x1368 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     810:	c8 01       	movw	r24, r16
     812:	df 91       	pop	r29
     814:	cf 91       	pop	r28
     816:	1f 91       	pop	r17
     818:	0f 91       	pop	r16
     81a:	08 95       	ret

0000081c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     81c:	0f 93       	push	r16
     81e:	1f 93       	push	r17
     820:	cf 93       	push	r28
     822:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     824:	00 97       	sbiw	r24, 0x00	; 0
     826:	41 f1       	breq	.+80     	; 0x878 <vPortFree+0x5c>
     828:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
     82a:	8c 01       	movw	r16, r24
     82c:	04 50       	subi	r16, 0x04	; 4
     82e:	11 09       	sbc	r17, r1

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
     830:	0e 94 a3 08 	call	0x1146	; 0x1146 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     834:	f8 01       	movw	r30, r16
     836:	42 81       	ldd	r20, Z+2	; 0x02
     838:	53 81       	ldd	r21, Z+3	; 0x03
     83a:	a3 ea       	ldi	r26, 0xA3	; 163
     83c:	b1 e0       	ldi	r27, 0x01	; 1
     83e:	01 c0       	rjmp	.+2      	; 0x842 <vPortFree+0x26>
     840:	df 01       	movw	r26, r30
     842:	ed 91       	ld	r30, X+
     844:	fc 91       	ld	r31, X
     846:	11 97       	sbiw	r26, 0x01	; 1
     848:	22 81       	ldd	r18, Z+2	; 0x02
     84a:	33 81       	ldd	r19, Z+3	; 0x03
     84c:	24 17       	cp	r18, r20
     84e:	35 07       	cpc	r19, r21
     850:	b8 f3       	brcs	.-18     	; 0x840 <vPortFree+0x24>
     852:	24 97       	sbiw	r28, 0x04	; 4
     854:	f9 83       	std	Y+1, r31	; 0x01
     856:	e8 83       	st	Y, r30
     858:	0d 93       	st	X+, r16
     85a:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
     85c:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__data_start>
     860:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__data_start+0x1>
     864:	8a 81       	ldd	r24, Y+2	; 0x02
     866:	9b 81       	ldd	r25, Y+3	; 0x03
     868:	82 0f       	add	r24, r18
     86a:	93 1f       	adc	r25, r19
     86c:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
     870:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
     874:	0e 94 b4 09 	call	0x1368	; 0x1368 <xTaskResumeAll>
	}
}
     878:	df 91       	pop	r29
     87a:	cf 91       	pop	r28
     87c:	1f 91       	pop	r17
     87e:	0f 91       	pop	r16
     880:	08 95       	ret

00000882 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     882:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     884:	03 96       	adiw	r24, 0x03	; 3
     886:	92 83       	std	Z+2, r25	; 0x02
     888:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     88a:	4f ef       	ldi	r20, 0xFF	; 255
     88c:	5f ef       	ldi	r21, 0xFF	; 255
     88e:	ba 01       	movw	r22, r20
     890:	43 83       	std	Z+3, r20	; 0x03
     892:	54 83       	std	Z+4, r21	; 0x04
     894:	65 83       	std	Z+5, r22	; 0x05
     896:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     898:	90 87       	std	Z+8, r25	; 0x08
     89a:	87 83       	std	Z+7, r24	; 0x07
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     89c:	92 87       	std	Z+10, r25	; 0x0a
     89e:	81 87       	std	Z+9, r24	; 0x09

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     8a0:	10 82       	st	Z, r1
     8a2:	08 95       	ret

000008a4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     8a4:	fc 01       	movw	r30, r24
     8a6:	13 86       	std	Z+11, r1	; 0x0b
     8a8:	12 86       	std	Z+10, r1	; 0x0a
     8aa:	08 95       	ret

000008ac <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     8ac:	cf 93       	push	r28
     8ae:	df 93       	push	r29
     8b0:	9c 01       	movw	r18, r24
     8b2:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     8b4:	dc 01       	movw	r26, r24
     8b6:	11 96       	adiw	r26, 0x01	; 1
     8b8:	cd 91       	ld	r28, X+
     8ba:	dc 91       	ld	r29, X
     8bc:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     8be:	d5 83       	std	Z+5, r29	; 0x05
     8c0:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     8c2:	8e 81       	ldd	r24, Y+6	; 0x06
     8c4:	9f 81       	ldd	r25, Y+7	; 0x07
     8c6:	97 83       	std	Z+7, r25	; 0x07
     8c8:	86 83       	std	Z+6, r24	; 0x06
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     8ca:	8e 81       	ldd	r24, Y+6	; 0x06
     8cc:	9f 81       	ldd	r25, Y+7	; 0x07
     8ce:	dc 01       	movw	r26, r24
     8d0:	15 96       	adiw	r26, 0x05	; 5
     8d2:	7c 93       	st	X, r23
     8d4:	6e 93       	st	-X, r22
     8d6:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxPrevious = pxNewListItem;
     8d8:	7f 83       	std	Y+7, r23	; 0x07
     8da:	6e 83       	std	Y+6, r22	; 0x06

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     8dc:	33 87       	std	Z+11, r19	; 0x0b
     8de:	22 87       	std	Z+10, r18	; 0x0a

	( pxList->uxNumberOfItems )++;
     8e0:	f9 01       	movw	r30, r18
     8e2:	80 81       	ld	r24, Z
     8e4:	8f 5f       	subi	r24, 0xFF	; 255
     8e6:	80 83       	st	Z, r24
}
     8e8:	df 91       	pop	r29
     8ea:	cf 91       	pop	r28
     8ec:	08 95       	ret

000008ee <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     8ee:	0f 93       	push	r16
     8f0:	1f 93       	push	r17
     8f2:	cf 93       	push	r28
     8f4:	df 93       	push	r29
     8f6:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     8f8:	08 81       	ld	r16, Y
     8fa:	19 81       	ldd	r17, Y+1	; 0x01
     8fc:	2a 81       	ldd	r18, Y+2	; 0x02
     8fe:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     900:	0f 3f       	cpi	r16, 0xFF	; 255
     902:	4f ef       	ldi	r20, 0xFF	; 255
     904:	14 07       	cpc	r17, r20
     906:	24 07       	cpc	r18, r20
     908:	34 07       	cpc	r19, r20
     90a:	21 f4       	brne	.+8      	; 0x914 <vListInsert+0x26>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     90c:	fc 01       	movw	r30, r24
     90e:	a1 85       	ldd	r26, Z+9	; 0x09
     910:	b2 85       	ldd	r27, Z+10	; 0x0a
     912:	11 c0       	rjmp	.+34     	; 0x936 <vListInsert+0x48>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     914:	dc 01       	movw	r26, r24
     916:	13 96       	adiw	r26, 0x03	; 3
     918:	01 c0       	rjmp	.+2      	; 0x91c <vListInsert+0x2e>
     91a:	df 01       	movw	r26, r30
     91c:	14 96       	adiw	r26, 0x04	; 4
     91e:	ed 91       	ld	r30, X+
     920:	fc 91       	ld	r31, X
     922:	15 97       	sbiw	r26, 0x05	; 5
     924:	40 81       	ld	r20, Z
     926:	51 81       	ldd	r21, Z+1	; 0x01
     928:	62 81       	ldd	r22, Z+2	; 0x02
     92a:	73 81       	ldd	r23, Z+3	; 0x03
     92c:	04 17       	cp	r16, r20
     92e:	15 07       	cpc	r17, r21
     930:	26 07       	cpc	r18, r22
     932:	37 07       	cpc	r19, r23
     934:	90 f7       	brcc	.-28     	; 0x91a <vListInsert+0x2c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     936:	14 96       	adiw	r26, 0x04	; 4
     938:	ed 91       	ld	r30, X+
     93a:	fc 91       	ld	r31, X
     93c:	15 97       	sbiw	r26, 0x05	; 5
     93e:	fd 83       	std	Y+5, r31	; 0x05
     940:	ec 83       	std	Y+4, r30	; 0x04
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     942:	d7 83       	std	Z+7, r29	; 0x07
     944:	c6 83       	std	Z+6, r28	; 0x06
	pxNewListItem->pxPrevious = pxIterator;
     946:	bf 83       	std	Y+7, r27	; 0x07
     948:	ae 83       	std	Y+6, r26	; 0x06
	pxIterator->pxNext = pxNewListItem;
     94a:	15 96       	adiw	r26, 0x05	; 5
     94c:	dc 93       	st	X, r29
     94e:	ce 93       	st	-X, r28
     950:	14 97       	sbiw	r26, 0x04	; 4

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     952:	9b 87       	std	Y+11, r25	; 0x0b
     954:	8a 87       	std	Y+10, r24	; 0x0a

	( pxList->uxNumberOfItems )++;
     956:	fc 01       	movw	r30, r24
     958:	20 81       	ld	r18, Z
     95a:	2f 5f       	subi	r18, 0xFF	; 255
     95c:	20 83       	st	Z, r18
}
     95e:	df 91       	pop	r29
     960:	cf 91       	pop	r28
     962:	1f 91       	pop	r17
     964:	0f 91       	pop	r16
     966:	08 95       	ret

00000968 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     968:	cf 93       	push	r28
     96a:	df 93       	push	r29
     96c:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     96e:	a2 85       	ldd	r26, Z+10	; 0x0a
     970:	b3 85       	ldd	r27, Z+11	; 0x0b

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     972:	c4 81       	ldd	r28, Z+4	; 0x04
     974:	d5 81       	ldd	r29, Z+5	; 0x05
     976:	86 81       	ldd	r24, Z+6	; 0x06
     978:	97 81       	ldd	r25, Z+7	; 0x07
     97a:	9f 83       	std	Y+7, r25	; 0x07
     97c:	8e 83       	std	Y+6, r24	; 0x06
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     97e:	c6 81       	ldd	r28, Z+6	; 0x06
     980:	d7 81       	ldd	r29, Z+7	; 0x07
     982:	84 81       	ldd	r24, Z+4	; 0x04
     984:	95 81       	ldd	r25, Z+5	; 0x05
     986:	9d 83       	std	Y+5, r25	; 0x05
     988:	8c 83       	std	Y+4, r24	; 0x04

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     98a:	11 96       	adiw	r26, 0x01	; 1
     98c:	8d 91       	ld	r24, X+
     98e:	9c 91       	ld	r25, X
     990:	12 97       	sbiw	r26, 0x02	; 2
     992:	e8 17       	cp	r30, r24
     994:	f9 07       	cpc	r31, r25
     996:	31 f4       	brne	.+12     	; 0x9a4 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     998:	86 81       	ldd	r24, Z+6	; 0x06
     99a:	97 81       	ldd	r25, Z+7	; 0x07
     99c:	12 96       	adiw	r26, 0x02	; 2
     99e:	9c 93       	st	X, r25
     9a0:	8e 93       	st	-X, r24
     9a2:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     9a4:	13 86       	std	Z+11, r1	; 0x0b
     9a6:	12 86       	std	Z+10, r1	; 0x0a
	( pxList->uxNumberOfItems )--;
     9a8:	8c 91       	ld	r24, X
     9aa:	81 50       	subi	r24, 0x01	; 1
     9ac:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     9ae:	df 91       	pop	r29
     9b0:	cf 91       	pop	r28
     9b2:	08 95       	ret

000009b4 <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
     9b4:	0e 94 74 03 	call	0x6e8	; 0x6e8 <pvPortMalloc>
     9b8:	08 95       	ret

000009ba <_ZdlPv>:
     9ba:	00 97       	sbiw	r24, 0x00	; 0
     9bc:	11 f0       	breq	.+4      	; 0x9c2 <_ZdlPv+0x8>
     9be:	0e 94 0e 04 	call	0x81c	; 0x81c <vPortFree>
     9c2:	08 95       	ret

000009c4 <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
     9c4:	08 95       	ret

000009c6 <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     9c6:	90 93 9b 0c 	sts	0x0C9B, r25	; 0x800c9b <portStackTopForTask+0x1>
     9ca:	80 93 9a 0c 	sts	0x0C9A, r24	; 0x800c9a <portStackTopForTask>
     9ce:	31 e1       	ldi	r19, 0x11	; 17
     9d0:	fc 01       	movw	r30, r24
     9d2:	30 83       	st	Z, r19
     9d4:	31 97       	sbiw	r30, 0x01	; 1
     9d6:	22 e2       	ldi	r18, 0x22	; 34
     9d8:	20 83       	st	Z, r18
     9da:	31 97       	sbiw	r30, 0x01	; 1
     9dc:	a3 e3       	ldi	r26, 0x33	; 51
     9de:	a0 83       	st	Z, r26
     9e0:	31 97       	sbiw	r30, 0x01	; 1
     9e2:	60 83       	st	Z, r22
     9e4:	31 97       	sbiw	r30, 0x01	; 1
     9e6:	70 83       	st	Z, r23
     9e8:	31 97       	sbiw	r30, 0x01	; 1
     9ea:	10 82       	st	Z, r1
     9ec:	31 97       	sbiw	r30, 0x01	; 1
     9ee:	60 e8       	ldi	r22, 0x80	; 128
     9f0:	60 83       	st	Z, r22
     9f2:	31 97       	sbiw	r30, 0x01	; 1
     9f4:	10 82       	st	Z, r1
     9f6:	31 97       	sbiw	r30, 0x01	; 1
     9f8:	62 e0       	ldi	r22, 0x02	; 2
     9fa:	60 83       	st	Z, r22
     9fc:	31 97       	sbiw	r30, 0x01	; 1
     9fe:	63 e0       	ldi	r22, 0x03	; 3
     a00:	60 83       	st	Z, r22
     a02:	31 97       	sbiw	r30, 0x01	; 1
     a04:	64 e0       	ldi	r22, 0x04	; 4
     a06:	60 83       	st	Z, r22
     a08:	31 97       	sbiw	r30, 0x01	; 1
     a0a:	65 e0       	ldi	r22, 0x05	; 5
     a0c:	60 83       	st	Z, r22
     a0e:	31 97       	sbiw	r30, 0x01	; 1
     a10:	66 e0       	ldi	r22, 0x06	; 6
     a12:	60 83       	st	Z, r22
     a14:	31 97       	sbiw	r30, 0x01	; 1
     a16:	67 e0       	ldi	r22, 0x07	; 7
     a18:	60 83       	st	Z, r22
     a1a:	31 97       	sbiw	r30, 0x01	; 1
     a1c:	68 e0       	ldi	r22, 0x08	; 8
     a1e:	60 83       	st	Z, r22
     a20:	31 97       	sbiw	r30, 0x01	; 1
     a22:	69 e0       	ldi	r22, 0x09	; 9
     a24:	60 83       	st	Z, r22
     a26:	31 97       	sbiw	r30, 0x01	; 1
     a28:	60 e1       	ldi	r22, 0x10	; 16
     a2a:	60 83       	st	Z, r22
     a2c:	31 97       	sbiw	r30, 0x01	; 1
     a2e:	30 83       	st	Z, r19
     a30:	31 97       	sbiw	r30, 0x01	; 1
     a32:	32 e1       	ldi	r19, 0x12	; 18
     a34:	30 83       	st	Z, r19
     a36:	31 97       	sbiw	r30, 0x01	; 1
     a38:	33 e1       	ldi	r19, 0x13	; 19
     a3a:	30 83       	st	Z, r19
     a3c:	31 97       	sbiw	r30, 0x01	; 1
     a3e:	34 e1       	ldi	r19, 0x14	; 20
     a40:	30 83       	st	Z, r19
     a42:	31 97       	sbiw	r30, 0x01	; 1
     a44:	35 e1       	ldi	r19, 0x15	; 21
     a46:	30 83       	st	Z, r19
     a48:	31 97       	sbiw	r30, 0x01	; 1
     a4a:	36 e1       	ldi	r19, 0x16	; 22
     a4c:	30 83       	st	Z, r19
     a4e:	31 97       	sbiw	r30, 0x01	; 1
     a50:	37 e1       	ldi	r19, 0x17	; 23
     a52:	30 83       	st	Z, r19
     a54:	31 97       	sbiw	r30, 0x01	; 1
     a56:	38 e1       	ldi	r19, 0x18	; 24
     a58:	30 83       	st	Z, r19
     a5a:	31 97       	sbiw	r30, 0x01	; 1
     a5c:	39 e1       	ldi	r19, 0x19	; 25
     a5e:	30 83       	st	Z, r19
     a60:	31 97       	sbiw	r30, 0x01	; 1
     a62:	30 e2       	ldi	r19, 0x20	; 32
     a64:	30 83       	st	Z, r19
     a66:	31 97       	sbiw	r30, 0x01	; 1
     a68:	31 e2       	ldi	r19, 0x21	; 33
     a6a:	30 83       	st	Z, r19
     a6c:	31 97       	sbiw	r30, 0x01	; 1
     a6e:	20 83       	st	Z, r18
     a70:	31 97       	sbiw	r30, 0x01	; 1
     a72:	23 e2       	ldi	r18, 0x23	; 35
     a74:	20 83       	st	Z, r18
     a76:	31 97       	sbiw	r30, 0x01	; 1
     a78:	40 83       	st	Z, r20
     a7a:	31 97       	sbiw	r30, 0x01	; 1
     a7c:	50 83       	st	Z, r21
     a7e:	31 97       	sbiw	r30, 0x01	; 1
     a80:	26 e2       	ldi	r18, 0x26	; 38
     a82:	20 83       	st	Z, r18
     a84:	31 97       	sbiw	r30, 0x01	; 1
     a86:	27 e2       	ldi	r18, 0x27	; 39
     a88:	20 83       	st	Z, r18
     a8a:	31 97       	sbiw	r30, 0x01	; 1
     a8c:	28 e2       	ldi	r18, 0x28	; 40
     a8e:	20 83       	st	Z, r18
     a90:	31 97       	sbiw	r30, 0x01	; 1
     a92:	29 e2       	ldi	r18, 0x29	; 41
     a94:	20 83       	st	Z, r18
     a96:	31 97       	sbiw	r30, 0x01	; 1
     a98:	20 e3       	ldi	r18, 0x30	; 48
     a9a:	20 83       	st	Z, r18
     a9c:	31 97       	sbiw	r30, 0x01	; 1
     a9e:	21 e3       	ldi	r18, 0x31	; 49
     aa0:	20 83       	st	Z, r18
     aa2:	86 97       	sbiw	r24, 0x26	; 38
     aa4:	08 95       	ret

00000aa6 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     aa6:	0f 92       	push	r0
     aa8:	0f b6       	in	r0, 0x3f	; 63
     aaa:	f8 94       	cli
     aac:	0f 92       	push	r0
     aae:	1f 92       	push	r1
     ab0:	11 24       	eor	r1, r1
     ab2:	2f 92       	push	r2
     ab4:	3f 92       	push	r3
     ab6:	4f 92       	push	r4
     ab8:	5f 92       	push	r5
     aba:	6f 92       	push	r6
     abc:	7f 92       	push	r7
     abe:	8f 92       	push	r8
     ac0:	9f 92       	push	r9
     ac2:	af 92       	push	r10
     ac4:	bf 92       	push	r11
     ac6:	cf 92       	push	r12
     ac8:	df 92       	push	r13
     aca:	ef 92       	push	r14
     acc:	ff 92       	push	r15
     ace:	0f 93       	push	r16
     ad0:	1f 93       	push	r17
     ad2:	2f 93       	push	r18
     ad4:	3f 93       	push	r19
     ad6:	4f 93       	push	r20
     ad8:	5f 93       	push	r21
     ada:	6f 93       	push	r22
     adc:	7f 93       	push	r23
     ade:	8f 93       	push	r24
     ae0:	9f 93       	push	r25
     ae2:	af 93       	push	r26
     ae4:	bf 93       	push	r27
     ae6:	cf 93       	push	r28
     ae8:	df 93       	push	r29
     aea:	ef 93       	push	r30
     aec:	ff 93       	push	r31
     aee:	a0 91 8a 0c 	lds	r26, 0x0C8A	; 0x800c8a <pxCurrentTCB>
     af2:	b0 91 8b 0c 	lds	r27, 0x0C8B	; 0x800c8b <pxCurrentTCB+0x1>
     af6:	0d b6       	in	r0, 0x3d	; 61
     af8:	0d 92       	st	X+, r0
     afa:	0e b6       	in	r0, 0x3e	; 62
     afc:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     afe:	0e 94 63 0a 	call	0x14c6	; 0x14c6 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     b02:	a0 91 8a 0c 	lds	r26, 0x0C8A	; 0x800c8a <pxCurrentTCB>
     b06:	b0 91 8b 0c 	lds	r27, 0x0C8B	; 0x800c8b <pxCurrentTCB+0x1>
     b0a:	cd 91       	ld	r28, X+
     b0c:	cd bf       	out	0x3d, r28	; 61
     b0e:	dd 91       	ld	r29, X+
     b10:	de bf       	out	0x3e, r29	; 62
     b12:	ff 91       	pop	r31
     b14:	ef 91       	pop	r30
     b16:	df 91       	pop	r29
     b18:	cf 91       	pop	r28
     b1a:	bf 91       	pop	r27
     b1c:	af 91       	pop	r26
     b1e:	9f 91       	pop	r25
     b20:	8f 91       	pop	r24
     b22:	7f 91       	pop	r23
     b24:	6f 91       	pop	r22
     b26:	5f 91       	pop	r21
     b28:	4f 91       	pop	r20
     b2a:	3f 91       	pop	r19
     b2c:	2f 91       	pop	r18
     b2e:	1f 91       	pop	r17
     b30:	0f 91       	pop	r16
     b32:	ff 90       	pop	r15
     b34:	ef 90       	pop	r14
     b36:	df 90       	pop	r13
     b38:	cf 90       	pop	r12
     b3a:	bf 90       	pop	r11
     b3c:	af 90       	pop	r10
     b3e:	9f 90       	pop	r9
     b40:	8f 90       	pop	r8
     b42:	7f 90       	pop	r7
     b44:	6f 90       	pop	r6
     b46:	5f 90       	pop	r5
     b48:	4f 90       	pop	r4
     b4a:	3f 90       	pop	r3
     b4c:	2f 90       	pop	r2
     b4e:	1f 90       	pop	r1
     b50:	0f 90       	pop	r0
     b52:	0f be       	out	0x3f, r0	; 63
     b54:	0f 90       	pop	r0

	asm volatile ( "ret" );
     b56:	08 95       	ret

00000b58 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     b58:	0f 92       	push	r0
     b5a:	0f b6       	in	r0, 0x3f	; 63
     b5c:	f8 94       	cli
     b5e:	0f 92       	push	r0
     b60:	1f 92       	push	r1
     b62:	11 24       	eor	r1, r1
     b64:	2f 92       	push	r2
     b66:	3f 92       	push	r3
     b68:	4f 92       	push	r4
     b6a:	5f 92       	push	r5
     b6c:	6f 92       	push	r6
     b6e:	7f 92       	push	r7
     b70:	8f 92       	push	r8
     b72:	9f 92       	push	r9
     b74:	af 92       	push	r10
     b76:	bf 92       	push	r11
     b78:	cf 92       	push	r12
     b7a:	df 92       	push	r13
     b7c:	ef 92       	push	r14
     b7e:	ff 92       	push	r15
     b80:	0f 93       	push	r16
     b82:	1f 93       	push	r17
     b84:	2f 93       	push	r18
     b86:	3f 93       	push	r19
     b88:	4f 93       	push	r20
     b8a:	5f 93       	push	r21
     b8c:	6f 93       	push	r22
     b8e:	7f 93       	push	r23
     b90:	8f 93       	push	r24
     b92:	9f 93       	push	r25
     b94:	af 93       	push	r26
     b96:	bf 93       	push	r27
     b98:	cf 93       	push	r28
     b9a:	df 93       	push	r29
     b9c:	ef 93       	push	r30
     b9e:	ff 93       	push	r31
     ba0:	a0 91 8a 0c 	lds	r26, 0x0C8A	; 0x800c8a <pxCurrentTCB>
     ba4:	b0 91 8b 0c 	lds	r27, 0x0C8B	; 0x800c8b <pxCurrentTCB+0x1>
     ba8:	0d b6       	in	r0, 0x3d	; 61
     baa:	0d 92       	st	X+, r0
     bac:	0e b6       	in	r0, 0x3e	; 62
     bae:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     bb0:	0e 94 b1 08 	call	0x1162	; 0x1162 <xTaskIncrementTick>
     bb4:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     bb6:	0e 94 63 0a 	call	0x14c6	; 0x14c6 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     bba:	a0 91 8a 0c 	lds	r26, 0x0C8A	; 0x800c8a <pxCurrentTCB>
     bbe:	b0 91 8b 0c 	lds	r27, 0x0C8B	; 0x800c8b <pxCurrentTCB+0x1>
     bc2:	cd 91       	ld	r28, X+
     bc4:	cd bf       	out	0x3d, r28	; 61
     bc6:	dd 91       	ld	r29, X+
     bc8:	de bf       	out	0x3e, r29	; 62
     bca:	ff 91       	pop	r31
     bcc:	ef 91       	pop	r30
     bce:	df 91       	pop	r29
     bd0:	cf 91       	pop	r28
     bd2:	bf 91       	pop	r27
     bd4:	af 91       	pop	r26
     bd6:	9f 91       	pop	r25
     bd8:	8f 91       	pop	r24
     bda:	7f 91       	pop	r23
     bdc:	6f 91       	pop	r22
     bde:	5f 91       	pop	r21
     be0:	4f 91       	pop	r20
     be2:	3f 91       	pop	r19
     be4:	2f 91       	pop	r18
     be6:	1f 91       	pop	r17
     be8:	0f 91       	pop	r16
     bea:	ff 90       	pop	r15
     bec:	ef 90       	pop	r14
     bee:	df 90       	pop	r13
     bf0:	cf 90       	pop	r12
     bf2:	bf 90       	pop	r11
     bf4:	af 90       	pop	r10
     bf6:	9f 90       	pop	r9
     bf8:	8f 90       	pop	r8
     bfa:	7f 90       	pop	r7
     bfc:	6f 90       	pop	r6
     bfe:	5f 90       	pop	r5
     c00:	4f 90       	pop	r4
     c02:	3f 90       	pop	r3
     c04:	2f 90       	pop	r2
     c06:	1f 90       	pop	r1
     c08:	0f 90       	pop	r0
     c0a:	0f be       	out	0x3f, r0	; 63
     c0c:	0f 90       	pop	r0

	asm volatile ( "ret" );
     c0e:	08 95       	ret

00000c10 <__vector_26>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
     c10:	0e 94 ac 05 	call	0xb58	; 0xb58 <vPortYieldFromTick>
		asm volatile ( "reti" );
     c14:	18 95       	reti

00000c16 <__vector_18>:
 *  This interrupt service routine runs whenever a character has been received by the
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

ISR (RSI_CHAR_RECV_INT_0)
{
     c16:	1f 92       	push	r1
     c18:	0f 92       	push	r0
     c1a:	0f b6       	in	r0, 0x3f	; 63
     c1c:	0f 92       	push	r0
     c1e:	11 24       	eor	r1, r1
     c20:	2f 93       	push	r18
     c22:	3f 93       	push	r19
     c24:	8f 93       	push	r24
     c26:	9f 93       	push	r25
     c28:	ef 93       	push	r30
     c2a:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	#if defined UCSR0A  // If this is a dual-serial-port chip (ATmega324P, 128, etc.)
		rcv0_buffer[rcv0_write_index] = UDR0;
     c2c:	2c b1       	in	r18, 0x0c	; 12
     c2e:	e0 91 29 0c 	lds	r30, 0x0C29	; 0x800c29 <rcv0_buffer>
     c32:	f0 91 2a 0c 	lds	r31, 0x0C2A	; 0x800c2a <rcv0_buffer+0x1>
     c36:	80 91 25 0c 	lds	r24, 0x0C25	; 0x800c25 <rcv0_write_index>
     c3a:	90 91 26 0c 	lds	r25, 0x0C26	; 0x800c26 <rcv0_write_index+0x1>
     c3e:	e8 0f       	add	r30, r24
     c40:	f9 1f       	adc	r31, r25
     c42:	20 83       	st	Z, r18
	#else  // If this chip has only a single serial port (ATmega8, 32, etc.)
		rcv0_buffer[rcv0_write_index] = UDR;
	#endif

	// Increment the write pointer
	if (++rcv0_write_index >= RSINT_BUF_SIZE)
     c44:	80 91 25 0c 	lds	r24, 0x0C25	; 0x800c25 <rcv0_write_index>
     c48:	90 91 26 0c 	lds	r25, 0x0C26	; 0x800c26 <rcv0_write_index+0x1>
     c4c:	01 96       	adiw	r24, 0x01	; 1
     c4e:	80 32       	cpi	r24, 0x20	; 32
     c50:	91 05       	cpc	r25, r1
     c52:	60 f4       	brcc	.+24     	; 0xc6c <__vector_18+0x56>
     c54:	90 93 26 0c 	sts	0x0C26, r25	; 0x800c26 <rcv0_write_index+0x1>
     c58:	80 93 25 0c 	sts	0x0C25, r24	; 0x800c25 <rcv0_write_index>
		rcv0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcv0_write_index == rcv0_read_index)
     c5c:	20 91 27 0c 	lds	r18, 0x0C27	; 0x800c27 <rcv0_read_index>
     c60:	30 91 28 0c 	lds	r19, 0x0C28	; 0x800c28 <rcv0_read_index+0x1>
     c64:	82 17       	cp	r24, r18
     c66:	93 07       	cpc	r25, r19
     c68:	f1 f4       	brne	.+60     	; 0xca6 <__vector_18+0x90>
     c6a:	0c c0       	rjmp	.+24     	; 0xc84 <__vector_18+0x6e>
		rcv0_buffer[rcv0_write_index] = UDR;
	#endif

	// Increment the write pointer
	if (++rcv0_write_index >= RSINT_BUF_SIZE)
		rcv0_write_index = 0;
     c6c:	10 92 26 0c 	sts	0x0C26, r1	; 0x800c26 <rcv0_write_index+0x1>
     c70:	10 92 25 0c 	sts	0x0C25, r1	; 0x800c25 <rcv0_write_index>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcv0_write_index == rcv0_read_index)
     c74:	80 91 27 0c 	lds	r24, 0x0C27	; 0x800c27 <rcv0_read_index>
     c78:	90 91 28 0c 	lds	r25, 0x0C28	; 0x800c28 <rcv0_read_index+0x1>
     c7c:	18 16       	cp	r1, r24
     c7e:	19 06       	cpc	r1, r25
     c80:	91 f4       	brne	.+36     	; 0xca6 <__vector_18+0x90>
     c82:	0e c0       	rjmp	.+28     	; 0xca0 <__vector_18+0x8a>
		if (++rcv0_read_index >= RSINT_BUF_SIZE)
     c84:	01 96       	adiw	r24, 0x01	; 1
     c86:	80 32       	cpi	r24, 0x20	; 32
     c88:	91 05       	cpc	r25, r1
     c8a:	28 f4       	brcc	.+10     	; 0xc96 <__vector_18+0x80>
     c8c:	90 93 28 0c 	sts	0x0C28, r25	; 0x800c28 <rcv0_read_index+0x1>
     c90:	80 93 27 0c 	sts	0x0C27, r24	; 0x800c27 <rcv0_read_index>
     c94:	08 c0       	rjmp	.+16     	; 0xca6 <__vector_18+0x90>
			rcv0_read_index = 0;
     c96:	10 92 28 0c 	sts	0x0C28, r1	; 0x800c28 <rcv0_read_index+0x1>
     c9a:	10 92 27 0c 	sts	0x0C27, r1	; 0x800c27 <rcv0_read_index>
}
     c9e:	03 c0       	rjmp	.+6      	; 0xca6 <__vector_18+0x90>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcv0_write_index == rcv0_read_index)
		if (++rcv0_read_index >= RSINT_BUF_SIZE)
     ca0:	81 e0       	ldi	r24, 0x01	; 1
     ca2:	90 e0       	ldi	r25, 0x00	; 0
     ca4:	f3 cf       	rjmp	.-26     	; 0xc8c <__vector_18+0x76>
			rcv0_read_index = 0;
}
     ca6:	ff 91       	pop	r31
     ca8:	ef 91       	pop	r30
     caa:	9f 91       	pop	r25
     cac:	8f 91       	pop	r24
     cae:	3f 91       	pop	r19
     cb0:	2f 91       	pop	r18
     cb2:	0f 90       	pop	r0
     cb4:	0f be       	out	0x3f, r0	; 63
     cb6:	0f 90       	pop	r0
     cb8:	1f 90       	pop	r1
     cba:	18 95       	reti

00000cbc <__vector_30>:
	/** This interrupt service routine runs whenever a character has been received by the
	*  first serial port (number 0).  It saves that character into the receiver buffer.
	*/

	ISR (RSI_CHAR_RECV_INT_1)
	{
     cbc:	1f 92       	push	r1
     cbe:	0f 92       	push	r0
     cc0:	0f b6       	in	r0, 0x3f	; 63
     cc2:	0f 92       	push	r0
     cc4:	11 24       	eor	r1, r1
     cc6:	2f 93       	push	r18
     cc8:	3f 93       	push	r19
     cca:	8f 93       	push	r24
     ccc:	9f 93       	push	r25
     cce:	ef 93       	push	r30
     cd0:	ff 93       	push	r31
		// Read the character from the serial port receiver buffer
		rcv1_buffer[rcv1_write_index] = UDR1;
     cd2:	20 91 9c 00 	lds	r18, 0x009C	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
     cd6:	e0 91 23 0c 	lds	r30, 0x0C23	; 0x800c23 <rcv1_buffer>
     cda:	f0 91 24 0c 	lds	r31, 0x0C24	; 0x800c24 <rcv1_buffer+0x1>
     cde:	80 91 1f 0c 	lds	r24, 0x0C1F	; 0x800c1f <rcv1_write_index>
     ce2:	90 91 20 0c 	lds	r25, 0x0C20	; 0x800c20 <rcv1_write_index+0x1>
     ce6:	e8 0f       	add	r30, r24
     ce8:	f9 1f       	adc	r31, r25
     cea:	20 83       	st	Z, r18

		// Increment the write pointer
		if (++rcv1_write_index >= RSINT_BUF_SIZE)
     cec:	80 91 1f 0c 	lds	r24, 0x0C1F	; 0x800c1f <rcv1_write_index>
     cf0:	90 91 20 0c 	lds	r25, 0x0C20	; 0x800c20 <rcv1_write_index+0x1>
     cf4:	01 96       	adiw	r24, 0x01	; 1
     cf6:	80 32       	cpi	r24, 0x20	; 32
     cf8:	91 05       	cpc	r25, r1
     cfa:	60 f4       	brcc	.+24     	; 0xd14 <__vector_30+0x58>
     cfc:	90 93 20 0c 	sts	0x0C20, r25	; 0x800c20 <rcv1_write_index+0x1>
     d00:	80 93 1f 0c 	sts	0x0C1F, r24	; 0x800c1f <rcv1_write_index>
			rcv1_write_index = 0;

		// If the write pointer is now equal to the read pointer, that means we've just
		// overwritten the oldest data. Increment the read pointer so that it doesn't seem
		// as if the buffer is empty
		if (rcv1_write_index == rcv1_read_index)
     d04:	20 91 21 0c 	lds	r18, 0x0C21	; 0x800c21 <rcv1_read_index>
     d08:	30 91 22 0c 	lds	r19, 0x0C22	; 0x800c22 <rcv1_read_index+0x1>
     d0c:	82 17       	cp	r24, r18
     d0e:	93 07       	cpc	r25, r19
     d10:	f1 f4       	brne	.+60     	; 0xd4e <__vector_30+0x92>
     d12:	0c c0       	rjmp	.+24     	; 0xd2c <__vector_30+0x70>
		// Read the character from the serial port receiver buffer
		rcv1_buffer[rcv1_write_index] = UDR1;

		// Increment the write pointer
		if (++rcv1_write_index >= RSINT_BUF_SIZE)
			rcv1_write_index = 0;
     d14:	10 92 20 0c 	sts	0x0C20, r1	; 0x800c20 <rcv1_write_index+0x1>
     d18:	10 92 1f 0c 	sts	0x0C1F, r1	; 0x800c1f <rcv1_write_index>

		// If the write pointer is now equal to the read pointer, that means we've just
		// overwritten the oldest data. Increment the read pointer so that it doesn't seem
		// as if the buffer is empty
		if (rcv1_write_index == rcv1_read_index)
     d1c:	80 91 21 0c 	lds	r24, 0x0C21	; 0x800c21 <rcv1_read_index>
     d20:	90 91 22 0c 	lds	r25, 0x0C22	; 0x800c22 <rcv1_read_index+0x1>
     d24:	18 16       	cp	r1, r24
     d26:	19 06       	cpc	r1, r25
     d28:	91 f4       	brne	.+36     	; 0xd4e <__vector_30+0x92>
     d2a:	0e c0       	rjmp	.+28     	; 0xd48 <__vector_30+0x8c>
			if (++rcv1_read_index >= RSINT_BUF_SIZE)
     d2c:	01 96       	adiw	r24, 0x01	; 1
     d2e:	80 32       	cpi	r24, 0x20	; 32
     d30:	91 05       	cpc	r25, r1
     d32:	28 f4       	brcc	.+10     	; 0xd3e <__vector_30+0x82>
     d34:	90 93 22 0c 	sts	0x0C22, r25	; 0x800c22 <rcv1_read_index+0x1>
     d38:	80 93 21 0c 	sts	0x0C21, r24	; 0x800c21 <rcv1_read_index>
     d3c:	08 c0       	rjmp	.+16     	; 0xd4e <__vector_30+0x92>
				rcv1_read_index = 0;
     d3e:	10 92 22 0c 	sts	0x0C22, r1	; 0x800c22 <rcv1_read_index+0x1>
     d42:	10 92 21 0c 	sts	0x0C21, r1	; 0x800c21 <rcv1_read_index>
	}
     d46:	03 c0       	rjmp	.+6      	; 0xd4e <__vector_30+0x92>

		// If the write pointer is now equal to the read pointer, that means we've just
		// overwritten the oldest data. Increment the read pointer so that it doesn't seem
		// as if the buffer is empty
		if (rcv1_write_index == rcv1_read_index)
			if (++rcv1_read_index >= RSINT_BUF_SIZE)
     d48:	81 e0       	ldi	r24, 0x01	; 1
     d4a:	90 e0       	ldi	r25, 0x00	; 0
     d4c:	f3 cf       	rjmp	.-26     	; 0xd34 <__vector_30+0x78>
				rcv1_read_index = 0;
	}
     d4e:	ff 91       	pop	r31
     d50:	ef 91       	pop	r30
     d52:	9f 91       	pop	r25
     d54:	8f 91       	pop	r24
     d56:	3f 91       	pop	r19
     d58:	2f 91       	pop	r18
     d5a:	0f 90       	pop	r0
     d5c:	0f be       	out	0x3f, r0	; 63
     d5e:	0f 90       	pop	r0
     d60:	1f 90       	pop	r1
     d62:	18 95       	reti

00000d64 <_ZN8TaskBaseC1EPKchjP8emstream>:
 *                        (default: @c configMINIMAL_STACK_SIZE)
 *  @param   p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which 
 *                     can be used by this task to communicate (default: NULL)
 */

TaskBase::TaskBase (const char* a_name, unsigned portBASE_TYPE a_priority, 
     d64:	6f 92       	push	r6
     d66:	7f 92       	push	r7
     d68:	8f 92       	push	r8
     d6a:	9f 92       	push	r9
     d6c:	af 92       	push	r10
     d6e:	bf 92       	push	r11
     d70:	cf 92       	push	r12
     d72:	df 92       	push	r13
     d74:	ef 92       	push	r14
     d76:	ff 92       	push	r15
     d78:	0f 93       	push	r16
     d7a:	1f 93       	push	r17
     d7c:	cf 93       	push	r28
     d7e:	df 93       	push	r29
     d80:	ec 01       	movw	r28, r24
     d82:	49 01       	movw	r8, r18
     d84:	38 01       	movw	r6, r16
					size_t a_stack_size, emstream* p_ser_dev)
     d86:	fc 01       	movw	r30, r24
     d88:	81 e6       	ldi	r24, 0x61	; 97
     d8a:	91 e0       	ldi	r25, 0x01	; 1
     d8c:	81 93       	st	Z+, r24
     d8e:	91 93       	st	Z+, r25
{
	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
     d90:	a1 2c       	mov	r10, r1
     d92:	b1 2c       	mov	r11, r1
     d94:	c1 2c       	mov	r12, r1
     d96:	d1 2c       	mov	r13, r1
     d98:	7f 01       	movw	r14, r30
     d9a:	04 2f       	mov	r16, r20
     d9c:	9e 01       	movw	r18, r28
     d9e:	a4 01       	movw	r20, r8
     da0:	81 e1       	ldi	r24, 0x11	; 17
     da2:	97 e0       	ldi	r25, 0x07	; 7
     da4:	0e 94 93 07 	call	0xf26	; 0xf26 <xTaskGenericCreate>
		 a_priority,                                // Priority for the new task
		 &handle                                    // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
     da8:	7f 82       	std	Y+7, r7	; 0x07
     daa:	6e 82       	std	Y+6, r6	; 0x06
	total_stack = a_stack_size;
     dac:	99 86       	std	Y+9, r9	; 0x09
     dae:	88 86       	std	Y+8, r8	; 0x08

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
     db0:	80 91 2b 0c 	lds	r24, 0x0C2B	; 0x800c2b <last_created_task_pointer>
     db4:	90 91 2c 0c 	lds	r25, 0x0C2C	; 0x800c2c <last_created_task_pointer+0x1>
     db8:	9d 83       	std	Y+5, r25	; 0x05
     dba:	8c 83       	std	Y+4, r24	; 0x04
	last_created_task_pointer = this;
     dbc:	d0 93 2c 0c 	sts	0x0C2C, r29	; 0x800c2c <last_created_task_pointer+0x1>
     dc0:	c0 93 2b 0c 	sts	0x0C2B, r28	; 0x800c2b <last_created_task_pointer>

	// Initialize the finite state machine and its transition logger
	state = 0;
     dc4:	1c 86       	std	Y+12, r1	; 0x0c
	previous_state = 0;
     dc6:	1d 86       	std	Y+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
     dc8:	80 91 9a 0c 	lds	r24, 0x0C9A	; 0x800c9a <portStackTopForTask>
     dcc:	90 91 9b 0c 	lds	r25, 0x0C9B	; 0x800c9b <portStackTopForTask+0x1>
     dd0:	01 96       	adiw	r24, 0x01	; 1
     dd2:	90 93 9b 0c 	sts	0x0C9B, r25	; 0x800c9b <portStackTopForTask+0x1>
     dd6:	80 93 9a 0c 	sts	0x0C9A, r24	; 0x800c9a <portStackTopForTask>
     dda:	9b 87       	std	Y+11, r25	; 0x0b
     ddc:	8a 87       	std	Y+10, r24	; 0x0a

	// Initialize the run counter
	runs = 0;
     dde:	1e 86       	std	Y+14, r1	; 0x0e
     de0:	1f 86       	std	Y+15, r1	; 0x0f
     de2:	18 8a       	std	Y+16, r1	; 0x10
     de4:	19 8a       	std	Y+17, r1	; 0x11
		{
			*p_serial << PMS ("ERROR creating task \"") << a_name << '"' << endl;
		}
		***/
	}
}
     de6:	df 91       	pop	r29
     de8:	cf 91       	pop	r28
     dea:	1f 91       	pop	r17
     dec:	0f 91       	pop	r16
     dee:	ff 90       	pop	r15
     df0:	ef 90       	pop	r14
     df2:	df 90       	pop	r13
     df4:	cf 90       	pop	r12
     df6:	bf 90       	pop	r11
     df8:	af 90       	pop	r10
     dfa:	9f 90       	pop	r9
     dfc:	8f 90       	pop	r8
     dfe:	7f 90       	pop	r7
     e00:	6f 90       	pop	r6
     e02:	08 95       	ret

00000e04 <_ZN8TaskBase22_call_users_run_methodEPS_>:
 *           it is the C (not C++) function which was registered with the scheduler.
 *  @param   p_task A pointer to the task (this task) whose run method is to be called
 */

void TaskBase::_call_users_run_method (TaskBase* p_task)
{
     e04:	ec 01       	movw	r28, r24
	// This is where the user's run() method is actually called
	p_task->run ();
     e06:	e8 81       	ld	r30, Y
     e08:	f9 81       	ldd	r31, Y+1	; 0x01
     e0a:	01 90       	ld	r0, Z+
     e0c:	f0 81       	ld	r31, Z
     e0e:	e0 2d       	mov	r30, r0
     e10:	09 95       	icall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
     e12:	1b 82       	std	Y+3, r1	; 0x03
     e14:	1a 82       	std	Y+2, r1	; 0x02

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
     e16:	6f ef       	ldi	r22, 0xFF	; 255
     e18:	7f ef       	ldi	r23, 0xFF	; 255
     e1a:	cb 01       	movw	r24, r22
     e1c:	0e 94 35 0a 	call	0x146a	; 0x146a <vTaskDelay>
     e20:	fa cf       	rjmp	.-12     	; 0xe16 <_ZN8TaskBase22_call_users_run_methodEPS_+0x12>

00000e22 <_call_static_run_method>:
 *                  function; the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (TaskBase* p_task)
{
	TaskBase::_call_users_run_method (p_task);
     e22:	0e 94 02 07 	call	0xe04	; 0xe04 <_ZN8TaskBase22_call_users_run_methodEPS_>

00000e26 <_ZN8TaskBase12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void TaskBase::print_status (emstream& ser_dev)
{
     e26:	0f 93       	push	r16
     e28:	1f 93       	push	r17
     e2a:	cf 93       	push	r28
     e2c:	df 93       	push	r29
     e2e:	8c 01       	movw	r16, r24
     e30:	eb 01       	movw	r28, r22
	ser_dev.puts (pcTaskGetTaskName (handle));
     e32:	fc 01       	movw	r30, r24
     e34:	82 81       	ldd	r24, Z+2	; 0x02
     e36:	93 81       	ldd	r25, Z+3	; 0x03
     e38:	0e 94 a9 08 	call	0x1152	; 0x1152 <pcTaskGetTaskName>
     e3c:	bc 01       	movw	r22, r24
     e3e:	ce 01       	movw	r24, r28
     e40:	0e 94 73 03 	call	0x6e6	; 0x6e6 <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
     e44:	e8 81       	ld	r30, Y
     e46:	f9 81       	ldd	r31, Y+1	; 0x01
     e48:	02 80       	ldd	r0, Z+2	; 0x02
     e4a:	f3 81       	ldd	r31, Z+3	; 0x03
     e4c:	e0 2d       	mov	r30, r0
     e4e:	69 e0       	ldi	r22, 0x09	; 9
     e50:	ce 01       	movw	r24, r28
     e52:	09 95       	icall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
     e54:	f8 01       	movw	r30, r16
     e56:	82 81       	ldd	r24, Z+2	; 0x02
     e58:	93 81       	ldd	r25, Z+3	; 0x03
     e5a:	0e 94 a9 08 	call	0x1152	; 0x1152 <pcTaskGetTaskName>
     e5e:	fc 01       	movw	r30, r24
     e60:	01 90       	ld	r0, Z+
     e62:	00 20       	and	r0, r0
     e64:	e9 f7       	brne	.-6      	; 0xe60 <_ZN8TaskBase12print_statusER8emstream+0x3a>
     e66:	31 97       	sbiw	r30, 0x01	; 1
     e68:	e8 1b       	sub	r30, r24
     e6a:	f9 0b       	sbc	r31, r25
     e6c:	38 97       	sbiw	r30, 0x08	; 8
     e6e:	40 f4       	brcc	.+16     	; 0xe80 <_ZN8TaskBase12print_statusER8emstream+0x5a>
	{
		ser_dev.putchar ('\t');
     e70:	e8 81       	ld	r30, Y
     e72:	f9 81       	ldd	r31, Y+1	; 0x01
     e74:	02 80       	ldd	r0, Z+2	; 0x02
     e76:	f3 81       	ldd	r31, Z+3	; 0x03
     e78:	e0 2d       	mov	r30, r0
     e7a:	69 e0       	ldi	r22, 0x09	; 9
     e7c:	ce 01       	movw	r24, r28
     e7e:	09 95       	icall
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< (size_t)(get_total_stack ()) << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
	***/
}
     e80:	df 91       	pop	r29
     e82:	cf 91       	pop	r28
     e84:	1f 91       	pop	r17
     e86:	0f 91       	pop	r16
     e88:	08 95       	ret

00000e8a <prvAddCurrentTaskToDelayedList>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     e8a:	cf 92       	push	r12
     e8c:	df 92       	push	r13
     e8e:	ef 92       	push	r14
     e90:	ff 92       	push	r15
     e92:	6b 01       	movw	r12, r22
     e94:	7c 01       	movw	r14, r24
     e96:	e0 91 8a 0c 	lds	r30, 0x0C8A	; 0x800c8a <pxCurrentTCB>
     e9a:	f0 91 8b 0c 	lds	r31, 0x0C8B	; 0x800c8b <pxCurrentTCB+0x1>
     e9e:	62 83       	std	Z+2, r22	; 0x02
     ea0:	73 83       	std	Z+3, r23	; 0x03
     ea2:	84 83       	std	Z+4, r24	; 0x04
     ea4:	95 83       	std	Z+5, r25	; 0x05
     ea6:	80 91 34 0c 	lds	r24, 0x0C34	; 0x800c34 <xTickCount>
     eaa:	90 91 35 0c 	lds	r25, 0x0C35	; 0x800c35 <xTickCount+0x1>
     eae:	a0 91 36 0c 	lds	r26, 0x0C36	; 0x800c36 <xTickCount+0x2>
     eb2:	b0 91 37 0c 	lds	r27, 0x0C37	; 0x800c37 <xTickCount+0x3>
     eb6:	c8 16       	cp	r12, r24
     eb8:	d9 06       	cpc	r13, r25
     eba:	ea 06       	cpc	r14, r26
     ebc:	fb 06       	cpc	r15, r27
     ebe:	68 f4       	brcc	.+26     	; 0xeda <prvAddCurrentTaskToDelayedList+0x50>
     ec0:	60 91 8a 0c 	lds	r22, 0x0C8A	; 0x800c8a <pxCurrentTCB>
     ec4:	70 91 8b 0c 	lds	r23, 0x0C8B	; 0x800c8b <pxCurrentTCB+0x1>
     ec8:	80 91 44 0c 	lds	r24, 0x0C44	; 0x800c44 <pxOverflowDelayedTaskList>
     ecc:	90 91 45 0c 	lds	r25, 0x0C45	; 0x800c45 <pxOverflowDelayedTaskList+0x1>
     ed0:	6e 5f       	subi	r22, 0xFE	; 254
     ed2:	7f 4f       	sbci	r23, 0xFF	; 255
     ed4:	0e 94 77 04 	call	0x8ee	; 0x8ee <vListInsert>
     ed8:	21 c0       	rjmp	.+66     	; 0xf1c <prvAddCurrentTaskToDelayedList+0x92>
     eda:	60 91 8a 0c 	lds	r22, 0x0C8A	; 0x800c8a <pxCurrentTCB>
     ede:	70 91 8b 0c 	lds	r23, 0x0C8B	; 0x800c8b <pxCurrentTCB+0x1>
     ee2:	80 91 46 0c 	lds	r24, 0x0C46	; 0x800c46 <pxDelayedTaskList>
     ee6:	90 91 47 0c 	lds	r25, 0x0C47	; 0x800c47 <pxDelayedTaskList+0x1>
     eea:	6e 5f       	subi	r22, 0xFE	; 254
     eec:	7f 4f       	sbci	r23, 0xFF	; 255
     eee:	0e 94 77 04 	call	0x8ee	; 0x8ee <vListInsert>
     ef2:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <xNextTaskUnblockTime>
     ef6:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <xNextTaskUnblockTime+0x1>
     efa:	a0 91 04 01 	lds	r26, 0x0104	; 0x800104 <xNextTaskUnblockTime+0x2>
     efe:	b0 91 05 01 	lds	r27, 0x0105	; 0x800105 <xNextTaskUnblockTime+0x3>
     f02:	c8 16       	cp	r12, r24
     f04:	d9 06       	cpc	r13, r25
     f06:	ea 06       	cpc	r14, r26
     f08:	fb 06       	cpc	r15, r27
     f0a:	40 f4       	brcc	.+16     	; 0xf1c <prvAddCurrentTaskToDelayedList+0x92>
     f0c:	c0 92 02 01 	sts	0x0102, r12	; 0x800102 <xNextTaskUnblockTime>
     f10:	d0 92 03 01 	sts	0x0103, r13	; 0x800103 <xNextTaskUnblockTime+0x1>
     f14:	e0 92 04 01 	sts	0x0104, r14	; 0x800104 <xNextTaskUnblockTime+0x2>
     f18:	f0 92 05 01 	sts	0x0105, r15	; 0x800105 <xNextTaskUnblockTime+0x3>
     f1c:	ff 90       	pop	r15
     f1e:	ef 90       	pop	r14
     f20:	df 90       	pop	r13
     f22:	cf 90       	pop	r12
     f24:	08 95       	ret

00000f26 <xTaskGenericCreate>:
     f26:	4f 92       	push	r4
     f28:	5f 92       	push	r5
     f2a:	6f 92       	push	r6
     f2c:	7f 92       	push	r7
     f2e:	8f 92       	push	r8
     f30:	9f 92       	push	r9
     f32:	af 92       	push	r10
     f34:	bf 92       	push	r11
     f36:	cf 92       	push	r12
     f38:	df 92       	push	r13
     f3a:	ef 92       	push	r14
     f3c:	ff 92       	push	r15
     f3e:	0f 93       	push	r16
     f40:	1f 93       	push	r17
     f42:	cf 93       	push	r28
     f44:	df 93       	push	r29
     f46:	4c 01       	movw	r8, r24
     f48:	eb 01       	movw	r28, r22
     f4a:	5a 01       	movw	r10, r20
     f4c:	29 01       	movw	r4, r18
     f4e:	89 e2       	ldi	r24, 0x29	; 41
     f50:	90 e0       	ldi	r25, 0x00	; 0
     f52:	0e 94 74 03 	call	0x6e8	; 0x6e8 <pvPortMalloc>
     f56:	3c 01       	movw	r6, r24
     f58:	00 97       	sbiw	r24, 0x00	; 0
     f5a:	09 f4       	brne	.+2      	; 0xf5e <xTaskGenericCreate+0x38>
     f5c:	e2 c0       	rjmp	.+452    	; 0x1122 <__stack+0x23>
     f5e:	c1 14       	cp	r12, r1
     f60:	d1 04       	cpc	r13, r1
     f62:	09 f0       	breq	.+2      	; 0xf66 <xTaskGenericCreate+0x40>
     f64:	d9 c0       	rjmp	.+434    	; 0x1118 <__stack+0x19>
     f66:	c5 01       	movw	r24, r10
     f68:	0e 94 74 03 	call	0x6e8	; 0x6e8 <pvPortMalloc>
     f6c:	f3 01       	movw	r30, r6
     f6e:	94 8f       	std	Z+28, r25	; 0x1c
     f70:	83 8f       	std	Z+27, r24	; 0x1b
     f72:	00 97       	sbiw	r24, 0x00	; 0
     f74:	21 f4       	brne	.+8      	; 0xf7e <xTaskGenericCreate+0x58>
     f76:	c3 01       	movw	r24, r6
     f78:	0e 94 0e 04 	call	0x81c	; 0x81c <vPortFree>
     f7c:	d2 c0       	rjmp	.+420    	; 0x1122 <__stack+0x23>
     f7e:	a5 01       	movw	r20, r10
     f80:	65 ea       	ldi	r22, 0xA5	; 165
     f82:	70 e0       	ldi	r23, 0x00	; 0
     f84:	0e 94 3a 0b 	call	0x1674	; 0x1674 <memset>
     f88:	f1 e0       	ldi	r31, 0x01	; 1
     f8a:	af 1a       	sub	r10, r31
     f8c:	b1 08       	sbc	r11, r1
     f8e:	f3 01       	movw	r30, r6
     f90:	83 8d       	ldd	r24, Z+27	; 0x1b
     f92:	94 8d       	ldd	r25, Z+28	; 0x1c
     f94:	a8 0e       	add	r10, r24
     f96:	b9 1e       	adc	r11, r25
     f98:	88 81       	ld	r24, Y
     f9a:	85 8f       	std	Z+29, r24	; 0x1d
     f9c:	88 81       	ld	r24, Y
     f9e:	88 23       	and	r24, r24
     fa0:	81 f0       	breq	.+32     	; 0xfc2 <xTaskGenericCreate+0x9c>
     fa2:	d3 01       	movw	r26, r6
     fa4:	5e 96       	adiw	r26, 0x1e	; 30
     fa6:	fe 01       	movw	r30, r28
     fa8:	31 96       	adiw	r30, 0x01	; 1
     faa:	9e 01       	movw	r18, r28
     fac:	26 5f       	subi	r18, 0xF6	; 246
     fae:	3f 4f       	sbci	r19, 0xFF	; 255
     fb0:	ef 01       	movw	r28, r30
     fb2:	81 91       	ld	r24, Z+
     fb4:	8d 93       	st	X+, r24
     fb6:	88 81       	ld	r24, Y
     fb8:	88 23       	and	r24, r24
     fba:	19 f0       	breq	.+6      	; 0xfc2 <xTaskGenericCreate+0x9c>
     fbc:	e2 17       	cp	r30, r18
     fbe:	f3 07       	cpc	r31, r19
     fc0:	b9 f7       	brne	.-18     	; 0xfb0 <xTaskGenericCreate+0x8a>
     fc2:	f3 01       	movw	r30, r6
     fc4:	16 a2       	std	Z+38, r1	; 0x26
     fc6:	10 2f       	mov	r17, r16
     fc8:	04 30       	cpi	r16, 0x04	; 4
     fca:	08 f0       	brcs	.+2      	; 0xfce <xTaskGenericCreate+0xa8>
     fcc:	13 e0       	ldi	r17, 0x03	; 3
     fce:	f3 01       	movw	r30, r6
     fd0:	12 8f       	std	Z+26, r17	; 0x1a
     fd2:	17 a3       	std	Z+39, r17	; 0x27
     fd4:	10 a6       	std	Z+40, r1	; 0x28
     fd6:	e3 01       	movw	r28, r6
     fd8:	22 96       	adiw	r28, 0x02	; 2
     fda:	ce 01       	movw	r24, r28
     fdc:	0e 94 52 04 	call	0x8a4	; 0x8a4 <vListInitialiseItem>
     fe0:	c3 01       	movw	r24, r6
     fe2:	0e 96       	adiw	r24, 0x0e	; 14
     fe4:	0e 94 52 04 	call	0x8a4	; 0x8a4 <vListInitialiseItem>
     fe8:	f3 01       	movw	r30, r6
     fea:	73 86       	std	Z+11, r7	; 0x0b
     fec:	62 86       	std	Z+10, r6	; 0x0a
     fee:	84 e0       	ldi	r24, 0x04	; 4
     ff0:	90 e0       	ldi	r25, 0x00	; 0
     ff2:	a0 e0       	ldi	r26, 0x00	; 0
     ff4:	b0 e0       	ldi	r27, 0x00	; 0
     ff6:	81 1b       	sub	r24, r17
     ff8:	91 09       	sbc	r25, r1
     ffa:	a1 09       	sbc	r26, r1
     ffc:	b1 09       	sbc	r27, r1
     ffe:	86 87       	std	Z+14, r24	; 0x0e
    1000:	97 87       	std	Z+15, r25	; 0x0f
    1002:	a0 8b       	std	Z+16, r26	; 0x10
    1004:	b1 8b       	std	Z+17, r27	; 0x11
    1006:	77 8a       	std	Z+23, r7	; 0x17
    1008:	66 8a       	std	Z+22, r6	; 0x16
    100a:	a2 01       	movw	r20, r4
    100c:	b4 01       	movw	r22, r8
    100e:	c5 01       	movw	r24, r10
    1010:	0e 94 e3 04 	call	0x9c6	; 0x9c6 <pxPortInitialiseStack>
    1014:	f3 01       	movw	r30, r6
    1016:	91 83       	std	Z+1, r25	; 0x01
    1018:	80 83       	st	Z, r24
    101a:	e1 14       	cp	r14, r1
    101c:	f1 04       	cpc	r15, r1
    101e:	19 f0       	breq	.+6      	; 0x1026 <xTaskGenericCreate+0x100>
    1020:	f7 01       	movw	r30, r14
    1022:	71 82       	std	Z+1, r7	; 0x01
    1024:	60 82       	st	Z, r6
    1026:	0f b6       	in	r0, 0x3f	; 63
    1028:	f8 94       	cli
    102a:	0f 92       	push	r0
    102c:	80 91 38 0c 	lds	r24, 0x0C38	; 0x800c38 <uxCurrentNumberOfTasks>
    1030:	8f 5f       	subi	r24, 0xFF	; 255
    1032:	80 93 38 0c 	sts	0x0C38, r24	; 0x800c38 <uxCurrentNumberOfTasks>
    1036:	80 91 8a 0c 	lds	r24, 0x0C8A	; 0x800c8a <pxCurrentTCB>
    103a:	90 91 8b 0c 	lds	r25, 0x0C8B	; 0x800c8b <pxCurrentTCB+0x1>
    103e:	89 2b       	or	r24, r25
    1040:	89 f5       	brne	.+98     	; 0x10a4 <xTaskGenericCreate+0x17e>
    1042:	70 92 8b 0c 	sts	0x0C8B, r7	; 0x800c8b <pxCurrentTCB+0x1>
    1046:	60 92 8a 0c 	sts	0x0C8A, r6	; 0x800c8a <pxCurrentTCB>
    104a:	80 91 38 0c 	lds	r24, 0x0C38	; 0x800c38 <uxCurrentNumberOfTasks>
    104e:	81 30       	cpi	r24, 0x01	; 1
    1050:	c1 f5       	brne	.+112    	; 0x10c2 <xTaskGenericCreate+0x19c>
    1052:	8e e5       	ldi	r24, 0x5E	; 94
    1054:	9c e0       	ldi	r25, 0x0C	; 12
    1056:	0e 94 41 04 	call	0x882	; 0x882 <vListInitialise>
    105a:	89 e6       	ldi	r24, 0x69	; 105
    105c:	9c e0       	ldi	r25, 0x0C	; 12
    105e:	0e 94 41 04 	call	0x882	; 0x882 <vListInitialise>
    1062:	84 e7       	ldi	r24, 0x74	; 116
    1064:	9c e0       	ldi	r25, 0x0C	; 12
    1066:	0e 94 41 04 	call	0x882	; 0x882 <vListInitialise>
    106a:	8f e7       	ldi	r24, 0x7F	; 127
    106c:	9c e0       	ldi	r25, 0x0C	; 12
    106e:	0e 94 41 04 	call	0x882	; 0x882 <vListInitialise>
    1072:	83 e5       	ldi	r24, 0x53	; 83
    1074:	9c e0       	ldi	r25, 0x0C	; 12
    1076:	0e 94 41 04 	call	0x882	; 0x882 <vListInitialise>
    107a:	88 e4       	ldi	r24, 0x48	; 72
    107c:	9c e0       	ldi	r25, 0x0C	; 12
    107e:	0e 94 41 04 	call	0x882	; 0x882 <vListInitialise>
    1082:	89 e3       	ldi	r24, 0x39	; 57
    1084:	9c e0       	ldi	r25, 0x0C	; 12
    1086:	0e 94 41 04 	call	0x882	; 0x882 <vListInitialise>
    108a:	83 e5       	ldi	r24, 0x53	; 83
    108c:	9c e0       	ldi	r25, 0x0C	; 12
    108e:	90 93 47 0c 	sts	0x0C47, r25	; 0x800c47 <pxDelayedTaskList+0x1>
    1092:	80 93 46 0c 	sts	0x0C46, r24	; 0x800c46 <pxDelayedTaskList>
    1096:	88 e4       	ldi	r24, 0x48	; 72
    1098:	9c e0       	ldi	r25, 0x0C	; 12
    109a:	90 93 45 0c 	sts	0x0C45, r25	; 0x800c45 <pxOverflowDelayedTaskList+0x1>
    109e:	80 93 44 0c 	sts	0x0C44, r24	; 0x800c44 <pxOverflowDelayedTaskList>
    10a2:	0f c0       	rjmp	.+30     	; 0x10c2 <xTaskGenericCreate+0x19c>
    10a4:	80 91 32 0c 	lds	r24, 0x0C32	; 0x800c32 <xSchedulerRunning>
    10a8:	81 11       	cpse	r24, r1
    10aa:	0b c0       	rjmp	.+22     	; 0x10c2 <xTaskGenericCreate+0x19c>
    10ac:	e0 91 8a 0c 	lds	r30, 0x0C8A	; 0x800c8a <pxCurrentTCB>
    10b0:	f0 91 8b 0c 	lds	r31, 0x0C8B	; 0x800c8b <pxCurrentTCB+0x1>
    10b4:	82 8d       	ldd	r24, Z+26	; 0x1a
    10b6:	08 17       	cp	r16, r24
    10b8:	20 f0       	brcs	.+8      	; 0x10c2 <xTaskGenericCreate+0x19c>
    10ba:	70 92 8b 0c 	sts	0x0C8B, r7	; 0x800c8b <pxCurrentTCB+0x1>
    10be:	60 92 8a 0c 	sts	0x0C8A, r6	; 0x800c8a <pxCurrentTCB>
    10c2:	80 91 2e 0c 	lds	r24, 0x0C2E	; 0x800c2e <uxTaskNumber>
    10c6:	8f 5f       	subi	r24, 0xFF	; 255
    10c8:	80 93 2e 0c 	sts	0x0C2E, r24	; 0x800c2e <uxTaskNumber>
    10cc:	f3 01       	movw	r30, r6
    10ce:	82 8d       	ldd	r24, Z+26	; 0x1a
    10d0:	90 91 33 0c 	lds	r25, 0x0C33	; 0x800c33 <uxTopReadyPriority>
    10d4:	98 17       	cp	r25, r24
    10d6:	10 f4       	brcc	.+4      	; 0x10dc <xTaskGenericCreate+0x1b6>
    10d8:	80 93 33 0c 	sts	0x0C33, r24	; 0x800c33 <uxTopReadyPriority>
    10dc:	fb e0       	ldi	r31, 0x0B	; 11
    10de:	8f 9f       	mul	r24, r31
    10e0:	c0 01       	movw	r24, r0
    10e2:	11 24       	eor	r1, r1
    10e4:	be 01       	movw	r22, r28
    10e6:	82 5a       	subi	r24, 0xA2	; 162
    10e8:	93 4f       	sbci	r25, 0xF3	; 243
    10ea:	0e 94 56 04 	call	0x8ac	; 0x8ac <vListInsertEnd>
    10ee:	0f 90       	pop	r0
    10f0:	0f be       	out	0x3f, r0	; 63
    10f2:	80 91 32 0c 	lds	r24, 0x0C32	; 0x800c32 <xSchedulerRunning>
    10f6:	88 23       	and	r24, r24
    10f8:	59 f0       	breq	.+22     	; 0x1110 <__stack+0x11>
    10fa:	e0 91 8a 0c 	lds	r30, 0x0C8A	; 0x800c8a <pxCurrentTCB>
    10fe:	f0 91 8b 0c 	lds	r31, 0x0C8B	; 0x800c8b <pxCurrentTCB+0x1>
    1102:	82 8d       	ldd	r24, Z+26	; 0x1a
    1104:	80 17       	cp	r24, r16
    1106:	30 f4       	brcc	.+12     	; 0x1114 <__stack+0x15>
    1108:	0e 94 53 05 	call	0xaa6	; 0xaa6 <vPortYield>
    110c:	81 e0       	ldi	r24, 0x01	; 1
    110e:	0a c0       	rjmp	.+20     	; 0x1124 <__stack+0x25>
    1110:	81 e0       	ldi	r24, 0x01	; 1
    1112:	08 c0       	rjmp	.+16     	; 0x1124 <__stack+0x25>
    1114:	81 e0       	ldi	r24, 0x01	; 1
    1116:	06 c0       	rjmp	.+12     	; 0x1124 <__stack+0x25>
    1118:	fc 01       	movw	r30, r24
    111a:	d4 8e       	std	Z+28, r13	; 0x1c
    111c:	c3 8e       	std	Z+27, r12	; 0x1b
    111e:	c6 01       	movw	r24, r12
    1120:	2e cf       	rjmp	.-420    	; 0xf7e <xTaskGenericCreate+0x58>
    1122:	8f ef       	ldi	r24, 0xFF	; 255
    1124:	df 91       	pop	r29
    1126:	cf 91       	pop	r28
    1128:	1f 91       	pop	r17
    112a:	0f 91       	pop	r16
    112c:	ff 90       	pop	r15
    112e:	ef 90       	pop	r14
    1130:	df 90       	pop	r13
    1132:	cf 90       	pop	r12
    1134:	bf 90       	pop	r11
    1136:	af 90       	pop	r10
    1138:	9f 90       	pop	r9
    113a:	8f 90       	pop	r8
    113c:	7f 90       	pop	r7
    113e:	6f 90       	pop	r6
    1140:	5f 90       	pop	r5
    1142:	4f 90       	pop	r4
    1144:	08 95       	ret

00001146 <vTaskSuspendAll>:
    1146:	80 91 2d 0c 	lds	r24, 0x0C2D	; 0x800c2d <uxSchedulerSuspended>
    114a:	8f 5f       	subi	r24, 0xFF	; 255
    114c:	80 93 2d 0c 	sts	0x0C2D, r24	; 0x800c2d <uxSchedulerSuspended>
    1150:	08 95       	ret

00001152 <pcTaskGetTaskName>:
    1152:	00 97       	sbiw	r24, 0x00	; 0
    1154:	21 f4       	brne	.+8      	; 0x115e <pcTaskGetTaskName+0xc>
    1156:	80 91 8a 0c 	lds	r24, 0x0C8A	; 0x800c8a <pxCurrentTCB>
    115a:	90 91 8b 0c 	lds	r25, 0x0C8B	; 0x800c8b <pxCurrentTCB+0x1>
    115e:	4d 96       	adiw	r24, 0x1d	; 29
    1160:	08 95       	ret

00001162 <xTaskIncrementTick>:
    1162:	9f 92       	push	r9
    1164:	af 92       	push	r10
    1166:	bf 92       	push	r11
    1168:	cf 92       	push	r12
    116a:	df 92       	push	r13
    116c:	ef 92       	push	r14
    116e:	ff 92       	push	r15
    1170:	0f 93       	push	r16
    1172:	1f 93       	push	r17
    1174:	cf 93       	push	r28
    1176:	df 93       	push	r29
    1178:	80 91 2d 0c 	lds	r24, 0x0C2D	; 0x800c2d <uxSchedulerSuspended>
    117c:	81 11       	cpse	r24, r1
    117e:	db c0       	rjmp	.+438    	; 0x1336 <xTaskIncrementTick+0x1d4>
    1180:	80 91 34 0c 	lds	r24, 0x0C34	; 0x800c34 <xTickCount>
    1184:	90 91 35 0c 	lds	r25, 0x0C35	; 0x800c35 <xTickCount+0x1>
    1188:	a0 91 36 0c 	lds	r26, 0x0C36	; 0x800c36 <xTickCount+0x2>
    118c:	b0 91 37 0c 	lds	r27, 0x0C37	; 0x800c37 <xTickCount+0x3>
    1190:	01 96       	adiw	r24, 0x01	; 1
    1192:	a1 1d       	adc	r26, r1
    1194:	b1 1d       	adc	r27, r1
    1196:	80 93 34 0c 	sts	0x0C34, r24	; 0x800c34 <xTickCount>
    119a:	90 93 35 0c 	sts	0x0C35, r25	; 0x800c35 <xTickCount+0x1>
    119e:	a0 93 36 0c 	sts	0x0C36, r26	; 0x800c36 <xTickCount+0x2>
    11a2:	b0 93 37 0c 	sts	0x0C37, r27	; 0x800c37 <xTickCount+0x3>
    11a6:	c0 90 34 0c 	lds	r12, 0x0C34	; 0x800c34 <xTickCount>
    11aa:	d0 90 35 0c 	lds	r13, 0x0C35	; 0x800c35 <xTickCount+0x1>
    11ae:	e0 90 36 0c 	lds	r14, 0x0C36	; 0x800c36 <xTickCount+0x2>
    11b2:	f0 90 37 0c 	lds	r15, 0x0C37	; 0x800c37 <xTickCount+0x3>
    11b6:	c1 14       	cp	r12, r1
    11b8:	d1 04       	cpc	r13, r1
    11ba:	e1 04       	cpc	r14, r1
    11bc:	f1 04       	cpc	r15, r1
    11be:	f1 f5       	brne	.+124    	; 0x123c <xTaskIncrementTick+0xda>
    11c0:	80 91 46 0c 	lds	r24, 0x0C46	; 0x800c46 <pxDelayedTaskList>
    11c4:	90 91 47 0c 	lds	r25, 0x0C47	; 0x800c47 <pxDelayedTaskList+0x1>
    11c8:	20 91 44 0c 	lds	r18, 0x0C44	; 0x800c44 <pxOverflowDelayedTaskList>
    11cc:	30 91 45 0c 	lds	r19, 0x0C45	; 0x800c45 <pxOverflowDelayedTaskList+0x1>
    11d0:	30 93 47 0c 	sts	0x0C47, r19	; 0x800c47 <pxDelayedTaskList+0x1>
    11d4:	20 93 46 0c 	sts	0x0C46, r18	; 0x800c46 <pxDelayedTaskList>
    11d8:	90 93 45 0c 	sts	0x0C45, r25	; 0x800c45 <pxOverflowDelayedTaskList+0x1>
    11dc:	80 93 44 0c 	sts	0x0C44, r24	; 0x800c44 <pxOverflowDelayedTaskList>
    11e0:	80 91 2f 0c 	lds	r24, 0x0C2F	; 0x800c2f <xNumOfOverflows>
    11e4:	8f 5f       	subi	r24, 0xFF	; 255
    11e6:	80 93 2f 0c 	sts	0x0C2F, r24	; 0x800c2f <xNumOfOverflows>
    11ea:	e0 91 46 0c 	lds	r30, 0x0C46	; 0x800c46 <pxDelayedTaskList>
    11ee:	f0 91 47 0c 	lds	r31, 0x0C47	; 0x800c47 <pxDelayedTaskList+0x1>
    11f2:	80 81       	ld	r24, Z
    11f4:	81 11       	cpse	r24, r1
    11f6:	0c c0       	rjmp	.+24     	; 0x1210 <xTaskIncrementTick+0xae>
    11f8:	8f ef       	ldi	r24, 0xFF	; 255
    11fa:	9f ef       	ldi	r25, 0xFF	; 255
    11fc:	dc 01       	movw	r26, r24
    11fe:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <xNextTaskUnblockTime>
    1202:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <xNextTaskUnblockTime+0x1>
    1206:	a0 93 04 01 	sts	0x0104, r26	; 0x800104 <xNextTaskUnblockTime+0x2>
    120a:	b0 93 05 01 	sts	0x0105, r27	; 0x800105 <xNextTaskUnblockTime+0x3>
    120e:	16 c0       	rjmp	.+44     	; 0x123c <xTaskIncrementTick+0xda>
    1210:	e0 91 46 0c 	lds	r30, 0x0C46	; 0x800c46 <pxDelayedTaskList>
    1214:	f0 91 47 0c 	lds	r31, 0x0C47	; 0x800c47 <pxDelayedTaskList+0x1>
    1218:	07 80       	ldd	r0, Z+7	; 0x07
    121a:	f0 85       	ldd	r31, Z+8	; 0x08
    121c:	e0 2d       	mov	r30, r0
    121e:	00 84       	ldd	r0, Z+8	; 0x08
    1220:	f1 85       	ldd	r31, Z+9	; 0x09
    1222:	e0 2d       	mov	r30, r0
    1224:	82 81       	ldd	r24, Z+2	; 0x02
    1226:	93 81       	ldd	r25, Z+3	; 0x03
    1228:	a4 81       	ldd	r26, Z+4	; 0x04
    122a:	b5 81       	ldd	r27, Z+5	; 0x05
    122c:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <xNextTaskUnblockTime>
    1230:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <xNextTaskUnblockTime+0x1>
    1234:	a0 93 04 01 	sts	0x0104, r26	; 0x800104 <xNextTaskUnblockTime+0x2>
    1238:	b0 93 05 01 	sts	0x0105, r27	; 0x800105 <xNextTaskUnblockTime+0x3>
    123c:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <xNextTaskUnblockTime>
    1240:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <xNextTaskUnblockTime+0x1>
    1244:	a0 91 04 01 	lds	r26, 0x0104	; 0x800104 <xNextTaskUnblockTime+0x2>
    1248:	b0 91 05 01 	lds	r27, 0x0105	; 0x800105 <xNextTaskUnblockTime+0x3>
    124c:	c8 16       	cp	r12, r24
    124e:	d9 06       	cpc	r13, r25
    1250:	ea 06       	cpc	r14, r26
    1252:	fb 06       	cpc	r15, r27
    1254:	10 f4       	brcc	.+4      	; 0x125a <xTaskIncrementTick+0xf8>
    1256:	b1 2c       	mov	r11, r1
    1258:	5d c0       	rjmp	.+186    	; 0x1314 <xTaskIncrementTick+0x1b2>
    125a:	b1 2c       	mov	r11, r1
    125c:	0f 2e       	mov	r0, r31
    125e:	fb e0       	ldi	r31, 0x0B	; 11
    1260:	af 2e       	mov	r10, r31
    1262:	f0 2d       	mov	r31, r0
    1264:	99 24       	eor	r9, r9
    1266:	93 94       	inc	r9
    1268:	e0 91 46 0c 	lds	r30, 0x0C46	; 0x800c46 <pxDelayedTaskList>
    126c:	f0 91 47 0c 	lds	r31, 0x0C47	; 0x800c47 <pxDelayedTaskList+0x1>
    1270:	80 81       	ld	r24, Z
    1272:	81 11       	cpse	r24, r1
    1274:	0c c0       	rjmp	.+24     	; 0x128e <xTaskIncrementTick+0x12c>
    1276:	8f ef       	ldi	r24, 0xFF	; 255
    1278:	9f ef       	ldi	r25, 0xFF	; 255
    127a:	dc 01       	movw	r26, r24
    127c:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <xNextTaskUnblockTime>
    1280:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <xNextTaskUnblockTime+0x1>
    1284:	a0 93 04 01 	sts	0x0104, r26	; 0x800104 <xNextTaskUnblockTime+0x2>
    1288:	b0 93 05 01 	sts	0x0105, r27	; 0x800105 <xNextTaskUnblockTime+0x3>
    128c:	43 c0       	rjmp	.+134    	; 0x1314 <xTaskIncrementTick+0x1b2>
    128e:	e0 91 46 0c 	lds	r30, 0x0C46	; 0x800c46 <pxDelayedTaskList>
    1292:	f0 91 47 0c 	lds	r31, 0x0C47	; 0x800c47 <pxDelayedTaskList+0x1>
    1296:	07 80       	ldd	r0, Z+7	; 0x07
    1298:	f0 85       	ldd	r31, Z+8	; 0x08
    129a:	e0 2d       	mov	r30, r0
    129c:	c0 85       	ldd	r28, Z+8	; 0x08
    129e:	d1 85       	ldd	r29, Z+9	; 0x09
    12a0:	8a 81       	ldd	r24, Y+2	; 0x02
    12a2:	9b 81       	ldd	r25, Y+3	; 0x03
    12a4:	ac 81       	ldd	r26, Y+4	; 0x04
    12a6:	bd 81       	ldd	r27, Y+5	; 0x05
    12a8:	c8 16       	cp	r12, r24
    12aa:	d9 06       	cpc	r13, r25
    12ac:	ea 06       	cpc	r14, r26
    12ae:	fb 06       	cpc	r15, r27
    12b0:	48 f4       	brcc	.+18     	; 0x12c4 <xTaskIncrementTick+0x162>
    12b2:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <xNextTaskUnblockTime>
    12b6:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <xNextTaskUnblockTime+0x1>
    12ba:	a0 93 04 01 	sts	0x0104, r26	; 0x800104 <xNextTaskUnblockTime+0x2>
    12be:	b0 93 05 01 	sts	0x0105, r27	; 0x800105 <xNextTaskUnblockTime+0x3>
    12c2:	28 c0       	rjmp	.+80     	; 0x1314 <xTaskIncrementTick+0x1b2>
    12c4:	8e 01       	movw	r16, r28
    12c6:	0e 5f       	subi	r16, 0xFE	; 254
    12c8:	1f 4f       	sbci	r17, 0xFF	; 255
    12ca:	c8 01       	movw	r24, r16
    12cc:	0e 94 b4 04 	call	0x968	; 0x968 <uxListRemove>
    12d0:	88 8d       	ldd	r24, Y+24	; 0x18
    12d2:	99 8d       	ldd	r25, Y+25	; 0x19
    12d4:	89 2b       	or	r24, r25
    12d6:	21 f0       	breq	.+8      	; 0x12e0 <xTaskIncrementTick+0x17e>
    12d8:	ce 01       	movw	r24, r28
    12da:	0e 96       	adiw	r24, 0x0e	; 14
    12dc:	0e 94 b4 04 	call	0x968	; 0x968 <uxListRemove>
    12e0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    12e2:	90 91 33 0c 	lds	r25, 0x0C33	; 0x800c33 <uxTopReadyPriority>
    12e6:	98 17       	cp	r25, r24
    12e8:	10 f4       	brcc	.+4      	; 0x12ee <xTaskIncrementTick+0x18c>
    12ea:	80 93 33 0c 	sts	0x0C33, r24	; 0x800c33 <uxTopReadyPriority>
    12ee:	a8 9e       	mul	r10, r24
    12f0:	c0 01       	movw	r24, r0
    12f2:	11 24       	eor	r1, r1
    12f4:	b8 01       	movw	r22, r16
    12f6:	82 5a       	subi	r24, 0xA2	; 162
    12f8:	93 4f       	sbci	r25, 0xF3	; 243
    12fa:	0e 94 56 04 	call	0x8ac	; 0x8ac <vListInsertEnd>
    12fe:	e0 91 8a 0c 	lds	r30, 0x0C8A	; 0x800c8a <pxCurrentTCB>
    1302:	f0 91 8b 0c 	lds	r31, 0x0C8B	; 0x800c8b <pxCurrentTCB+0x1>
    1306:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1308:	82 8d       	ldd	r24, Z+26	; 0x1a
    130a:	98 17       	cp	r25, r24
    130c:	08 f4       	brcc	.+2      	; 0x1310 <xTaskIncrementTick+0x1ae>
    130e:	ac cf       	rjmp	.-168    	; 0x1268 <xTaskIncrementTick+0x106>
    1310:	b9 2c       	mov	r11, r9
    1312:	aa cf       	rjmp	.-172    	; 0x1268 <xTaskIncrementTick+0x106>
    1314:	e0 91 8a 0c 	lds	r30, 0x0C8A	; 0x800c8a <pxCurrentTCB>
    1318:	f0 91 8b 0c 	lds	r31, 0x0C8B	; 0x800c8b <pxCurrentTCB+0x1>
    131c:	e2 8d       	ldd	r30, Z+26	; 0x1a
    131e:	8b e0       	ldi	r24, 0x0B	; 11
    1320:	e8 9f       	mul	r30, r24
    1322:	f0 01       	movw	r30, r0
    1324:	11 24       	eor	r1, r1
    1326:	e2 5a       	subi	r30, 0xA2	; 162
    1328:	f3 4f       	sbci	r31, 0xF3	; 243
    132a:	80 81       	ld	r24, Z
    132c:	82 30       	cpi	r24, 0x02	; 2
    132e:	48 f0       	brcs	.+18     	; 0x1342 <xTaskIncrementTick+0x1e0>
    1330:	bb 24       	eor	r11, r11
    1332:	b3 94       	inc	r11
    1334:	06 c0       	rjmp	.+12     	; 0x1342 <xTaskIncrementTick+0x1e0>
    1336:	80 91 31 0c 	lds	r24, 0x0C31	; 0x800c31 <uxPendedTicks>
    133a:	8f 5f       	subi	r24, 0xFF	; 255
    133c:	80 93 31 0c 	sts	0x0C31, r24	; 0x800c31 <uxPendedTicks>
    1340:	b1 2c       	mov	r11, r1
    1342:	80 91 30 0c 	lds	r24, 0x0C30	; 0x800c30 <xYieldPending>
    1346:	88 23       	and	r24, r24
    1348:	11 f0       	breq	.+4      	; 0x134e <xTaskIncrementTick+0x1ec>
    134a:	bb 24       	eor	r11, r11
    134c:	b3 94       	inc	r11
    134e:	8b 2d       	mov	r24, r11
    1350:	df 91       	pop	r29
    1352:	cf 91       	pop	r28
    1354:	1f 91       	pop	r17
    1356:	0f 91       	pop	r16
    1358:	ff 90       	pop	r15
    135a:	ef 90       	pop	r14
    135c:	df 90       	pop	r13
    135e:	cf 90       	pop	r12
    1360:	bf 90       	pop	r11
    1362:	af 90       	pop	r10
    1364:	9f 90       	pop	r9
    1366:	08 95       	ret

00001368 <xTaskResumeAll>:
    1368:	cf 92       	push	r12
    136a:	df 92       	push	r13
    136c:	ef 92       	push	r14
    136e:	ff 92       	push	r15
    1370:	0f 93       	push	r16
    1372:	1f 93       	push	r17
    1374:	cf 93       	push	r28
    1376:	df 93       	push	r29
    1378:	0f b6       	in	r0, 0x3f	; 63
    137a:	f8 94       	cli
    137c:	0f 92       	push	r0
    137e:	80 91 2d 0c 	lds	r24, 0x0C2D	; 0x800c2d <uxSchedulerSuspended>
    1382:	81 50       	subi	r24, 0x01	; 1
    1384:	80 93 2d 0c 	sts	0x0C2D, r24	; 0x800c2d <uxSchedulerSuspended>
    1388:	80 91 2d 0c 	lds	r24, 0x0C2D	; 0x800c2d <uxSchedulerSuspended>
    138c:	81 11       	cpse	r24, r1
    138e:	5f c0       	rjmp	.+190    	; 0x144e <xTaskResumeAll+0xe6>
    1390:	80 91 38 0c 	lds	r24, 0x0C38	; 0x800c38 <uxCurrentNumberOfTasks>
    1394:	81 11       	cpse	r24, r1
    1396:	2c c0       	rjmp	.+88     	; 0x13f0 <xTaskResumeAll+0x88>
    1398:	5d c0       	rjmp	.+186    	; 0x1454 <xTaskResumeAll+0xec>
    139a:	d7 01       	movw	r26, r14
    139c:	17 96       	adiw	r26, 0x07	; 7
    139e:	ed 91       	ld	r30, X+
    13a0:	fc 91       	ld	r31, X
    13a2:	18 97       	sbiw	r26, 0x08	; 8
    13a4:	c0 85       	ldd	r28, Z+8	; 0x08
    13a6:	d1 85       	ldd	r29, Z+9	; 0x09
    13a8:	ce 01       	movw	r24, r28
    13aa:	0e 96       	adiw	r24, 0x0e	; 14
    13ac:	0e 94 b4 04 	call	0x968	; 0x968 <uxListRemove>
    13b0:	8e 01       	movw	r16, r28
    13b2:	0e 5f       	subi	r16, 0xFE	; 254
    13b4:	1f 4f       	sbci	r17, 0xFF	; 255
    13b6:	c8 01       	movw	r24, r16
    13b8:	0e 94 b4 04 	call	0x968	; 0x968 <uxListRemove>
    13bc:	8a 8d       	ldd	r24, Y+26	; 0x1a
    13be:	90 91 33 0c 	lds	r25, 0x0C33	; 0x800c33 <uxTopReadyPriority>
    13c2:	98 17       	cp	r25, r24
    13c4:	10 f4       	brcc	.+4      	; 0x13ca <xTaskResumeAll+0x62>
    13c6:	80 93 33 0c 	sts	0x0C33, r24	; 0x800c33 <uxTopReadyPriority>
    13ca:	d8 9e       	mul	r13, r24
    13cc:	c0 01       	movw	r24, r0
    13ce:	11 24       	eor	r1, r1
    13d0:	b8 01       	movw	r22, r16
    13d2:	82 5a       	subi	r24, 0xA2	; 162
    13d4:	93 4f       	sbci	r25, 0xF3	; 243
    13d6:	0e 94 56 04 	call	0x8ac	; 0x8ac <vListInsertEnd>
    13da:	e0 91 8a 0c 	lds	r30, 0x0C8A	; 0x800c8a <pxCurrentTCB>
    13de:	f0 91 8b 0c 	lds	r31, 0x0C8B	; 0x800c8b <pxCurrentTCB+0x1>
    13e2:	9a 8d       	ldd	r25, Y+26	; 0x1a
    13e4:	82 8d       	ldd	r24, Z+26	; 0x1a
    13e6:	98 17       	cp	r25, r24
    13e8:	78 f0       	brcs	.+30     	; 0x1408 <xTaskResumeAll+0xa0>
    13ea:	c0 92 30 0c 	sts	0x0C30, r12	; 0x800c30 <xYieldPending>
    13ee:	0c c0       	rjmp	.+24     	; 0x1408 <xTaskResumeAll+0xa0>
    13f0:	0f 2e       	mov	r0, r31
    13f2:	f9 e3       	ldi	r31, 0x39	; 57
    13f4:	ef 2e       	mov	r14, r31
    13f6:	fc e0       	ldi	r31, 0x0C	; 12
    13f8:	ff 2e       	mov	r15, r31
    13fa:	f0 2d       	mov	r31, r0
    13fc:	0f 2e       	mov	r0, r31
    13fe:	fb e0       	ldi	r31, 0x0B	; 11
    1400:	df 2e       	mov	r13, r31
    1402:	f0 2d       	mov	r31, r0
    1404:	cc 24       	eor	r12, r12
    1406:	c3 94       	inc	r12
    1408:	f7 01       	movw	r30, r14
    140a:	80 81       	ld	r24, Z
    140c:	81 11       	cpse	r24, r1
    140e:	c5 cf       	rjmp	.-118    	; 0x139a <xTaskResumeAll+0x32>
    1410:	80 91 31 0c 	lds	r24, 0x0C31	; 0x800c31 <uxPendedTicks>
    1414:	88 23       	and	r24, r24
    1416:	99 f0       	breq	.+38     	; 0x143e <xTaskResumeAll+0xd6>
    1418:	80 91 31 0c 	lds	r24, 0x0C31	; 0x800c31 <uxPendedTicks>
    141c:	88 23       	and	r24, r24
    141e:	79 f0       	breq	.+30     	; 0x143e <xTaskResumeAll+0xd6>
    1420:	c1 e0       	ldi	r28, 0x01	; 1
    1422:	0e 94 b1 08 	call	0x1162	; 0x1162 <xTaskIncrementTick>
    1426:	81 11       	cpse	r24, r1
    1428:	c0 93 30 0c 	sts	0x0C30, r28	; 0x800c30 <xYieldPending>
    142c:	80 91 31 0c 	lds	r24, 0x0C31	; 0x800c31 <uxPendedTicks>
    1430:	81 50       	subi	r24, 0x01	; 1
    1432:	80 93 31 0c 	sts	0x0C31, r24	; 0x800c31 <uxPendedTicks>
    1436:	80 91 31 0c 	lds	r24, 0x0C31	; 0x800c31 <uxPendedTicks>
    143a:	81 11       	cpse	r24, r1
    143c:	f2 cf       	rjmp	.-28     	; 0x1422 <xTaskResumeAll+0xba>
    143e:	80 91 30 0c 	lds	r24, 0x0C30	; 0x800c30 <xYieldPending>
    1442:	81 30       	cpi	r24, 0x01	; 1
    1444:	31 f4       	brne	.+12     	; 0x1452 <xTaskResumeAll+0xea>
    1446:	0e 94 53 05 	call	0xaa6	; 0xaa6 <vPortYield>
    144a:	81 e0       	ldi	r24, 0x01	; 1
    144c:	03 c0       	rjmp	.+6      	; 0x1454 <xTaskResumeAll+0xec>
    144e:	80 e0       	ldi	r24, 0x00	; 0
    1450:	01 c0       	rjmp	.+2      	; 0x1454 <xTaskResumeAll+0xec>
    1452:	80 e0       	ldi	r24, 0x00	; 0
    1454:	0f 90       	pop	r0
    1456:	0f be       	out	0x3f, r0	; 63
    1458:	df 91       	pop	r29
    145a:	cf 91       	pop	r28
    145c:	1f 91       	pop	r17
    145e:	0f 91       	pop	r16
    1460:	ff 90       	pop	r15
    1462:	ef 90       	pop	r14
    1464:	df 90       	pop	r13
    1466:	cf 90       	pop	r12
    1468:	08 95       	ret

0000146a <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    146a:	cf 92       	push	r12
    146c:	df 92       	push	r13
    146e:	ef 92       	push	r14
    1470:	ff 92       	push	r15
    1472:	6b 01       	movw	r12, r22
    1474:	7c 01       	movw	r14, r24
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    1476:	67 2b       	or	r22, r23
    1478:	68 2b       	or	r22, r24
    147a:	69 2b       	or	r22, r25
    147c:	e9 f0       	breq	.+58     	; 0x14b8 <vTaskDelay+0x4e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    147e:	0e 94 a3 08 	call	0x1146	; 0x1146 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1482:	80 91 34 0c 	lds	r24, 0x0C34	; 0x800c34 <xTickCount>
    1486:	90 91 35 0c 	lds	r25, 0x0C35	; 0x800c35 <xTickCount+0x1>
    148a:	a0 91 36 0c 	lds	r26, 0x0C36	; 0x800c36 <xTickCount+0x2>
    148e:	b0 91 37 0c 	lds	r27, 0x0C37	; 0x800c37 <xTickCount+0x3>
    1492:	c8 0e       	add	r12, r24
    1494:	d9 1e       	adc	r13, r25
    1496:	ea 1e       	adc	r14, r26
    1498:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    149a:	80 91 8a 0c 	lds	r24, 0x0C8A	; 0x800c8a <pxCurrentTCB>
    149e:	90 91 8b 0c 	lds	r25, 0x0C8B	; 0x800c8b <pxCurrentTCB+0x1>
    14a2:	02 96       	adiw	r24, 0x02	; 2
    14a4:	0e 94 b4 04 	call	0x968	; 0x968 <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    14a8:	c7 01       	movw	r24, r14
    14aa:	b6 01       	movw	r22, r12
    14ac:	0e 94 45 07 	call	0xe8a	; 0xe8a <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    14b0:	0e 94 b4 09 	call	0x1368	; 0x1368 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    14b4:	81 11       	cpse	r24, r1
    14b6:	02 c0       	rjmp	.+4      	; 0x14bc <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    14b8:	0e 94 53 05 	call	0xaa6	; 0xaa6 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    14bc:	ff 90       	pop	r15
    14be:	ef 90       	pop	r14
    14c0:	df 90       	pop	r13
    14c2:	cf 90       	pop	r12
    14c4:	08 95       	ret

000014c6 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    14c6:	80 91 2d 0c 	lds	r24, 0x0C2D	; 0x800c2d <uxSchedulerSuspended>
    14ca:	88 23       	and	r24, r24
    14cc:	21 f0       	breq	.+8      	; 0x14d6 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    14ce:	81 e0       	ldi	r24, 0x01	; 1
    14d0:	80 93 30 0c 	sts	0x0C30, r24	; 0x800c30 <xYieldPending>
    14d4:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    14d6:	10 92 30 0c 	sts	0x0C30, r1	; 0x800c30 <xYieldPending>
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    14da:	e0 91 33 0c 	lds	r30, 0x0C33	; 0x800c33 <uxTopReadyPriority>
    14de:	4b e0       	ldi	r20, 0x0B	; 11
    14e0:	e4 9f       	mul	r30, r20
    14e2:	f0 01       	movw	r30, r0
    14e4:	11 24       	eor	r1, r1
    14e6:	e2 5a       	subi	r30, 0xA2	; 162
    14e8:	f3 4f       	sbci	r31, 0xF3	; 243
    14ea:	80 81       	ld	r24, Z
    14ec:	81 11       	cpse	r24, r1
    14ee:	10 c0       	rjmp	.+32     	; 0x1510 <vTaskSwitchContext+0x4a>
    14f0:	9b e0       	ldi	r25, 0x0B	; 11
    14f2:	80 91 33 0c 	lds	r24, 0x0C33	; 0x800c33 <uxTopReadyPriority>
    14f6:	81 50       	subi	r24, 0x01	; 1
    14f8:	80 93 33 0c 	sts	0x0C33, r24	; 0x800c33 <uxTopReadyPriority>
    14fc:	e0 91 33 0c 	lds	r30, 0x0C33	; 0x800c33 <uxTopReadyPriority>
    1500:	9e 9f       	mul	r25, r30
    1502:	f0 01       	movw	r30, r0
    1504:	11 24       	eor	r1, r1
    1506:	e2 5a       	subi	r30, 0xA2	; 162
    1508:	f3 4f       	sbci	r31, 0xF3	; 243
    150a:	80 81       	ld	r24, Z
    150c:	88 23       	and	r24, r24
    150e:	89 f3       	breq	.-30     	; 0x14f2 <vTaskSwitchContext+0x2c>
    1510:	80 91 33 0c 	lds	r24, 0x0C33	; 0x800c33 <uxTopReadyPriority>
    1514:	28 2f       	mov	r18, r24
    1516:	30 e0       	ldi	r19, 0x00	; 0
    1518:	4b e0       	ldi	r20, 0x0B	; 11
    151a:	84 9f       	mul	r24, r20
    151c:	c0 01       	movw	r24, r0
    151e:	11 24       	eor	r1, r1
    1520:	dc 01       	movw	r26, r24
    1522:	a2 5a       	subi	r26, 0xA2	; 162
    1524:	b3 4f       	sbci	r27, 0xF3	; 243
    1526:	11 96       	adiw	r26, 0x01	; 1
    1528:	ed 91       	ld	r30, X+
    152a:	fc 91       	ld	r31, X
    152c:	12 97       	sbiw	r26, 0x02	; 2
    152e:	04 80       	ldd	r0, Z+4	; 0x04
    1530:	f5 81       	ldd	r31, Z+5	; 0x05
    1532:	e0 2d       	mov	r30, r0
    1534:	12 96       	adiw	r26, 0x02	; 2
    1536:	fc 93       	st	X, r31
    1538:	ee 93       	st	-X, r30
    153a:	11 97       	sbiw	r26, 0x01	; 1
    153c:	8f 59       	subi	r24, 0x9F	; 159
    153e:	93 4f       	sbci	r25, 0xF3	; 243
    1540:	e8 17       	cp	r30, r24
    1542:	f9 07       	cpc	r31, r25
    1544:	61 f4       	brne	.+24     	; 0x155e <vTaskSwitchContext+0x98>
    1546:	84 81       	ldd	r24, Z+4	; 0x04
    1548:	95 81       	ldd	r25, Z+5	; 0x05
    154a:	4b e0       	ldi	r20, 0x0B	; 11
    154c:	42 9f       	mul	r20, r18
    154e:	f0 01       	movw	r30, r0
    1550:	43 9f       	mul	r20, r19
    1552:	f0 0d       	add	r31, r0
    1554:	11 24       	eor	r1, r1
    1556:	e2 5a       	subi	r30, 0xA2	; 162
    1558:	f3 4f       	sbci	r31, 0xF3	; 243
    155a:	92 83       	std	Z+2, r25	; 0x02
    155c:	81 83       	std	Z+1, r24	; 0x01
    155e:	8b e0       	ldi	r24, 0x0B	; 11
    1560:	82 9f       	mul	r24, r18
    1562:	f0 01       	movw	r30, r0
    1564:	83 9f       	mul	r24, r19
    1566:	f0 0d       	add	r31, r0
    1568:	11 24       	eor	r1, r1
    156a:	e2 5a       	subi	r30, 0xA2	; 162
    156c:	f3 4f       	sbci	r31, 0xF3	; 243
    156e:	01 80       	ldd	r0, Z+1	; 0x01
    1570:	f2 81       	ldd	r31, Z+2	; 0x02
    1572:	e0 2d       	mov	r30, r0
    1574:	80 85       	ldd	r24, Z+8	; 0x08
    1576:	91 85       	ldd	r25, Z+9	; 0x09
    1578:	90 93 8b 0c 	sts	0x0C8B, r25	; 0x800c8b <pxCurrentTCB+0x1>
    157c:	80 93 8a 0c 	sts	0x0C8A, r24	; 0x800c8a <pxCurrentTCB>
    1580:	08 95       	ret

00001582 <main>:

using namespace std;
#define nullptr NULL
const uint8_t N_MULTI_TASKS = 8;

int main() {
    1582:	8f 92       	push	r8
    1584:	9f 92       	push	r9
    1586:	af 92       	push	r10
    1588:	cf 92       	push	r12
    158a:	df 92       	push	r13
    158c:	ef 92       	push	r14
    158e:	ff 92       	push	r15
    1590:	0f 93       	push	r16
    1592:	1f 93       	push	r17
    1594:	cf 93       	push	r28
    1596:	df 93       	push	r29
    1598:	1f 92       	push	r1
    159a:	cd b7       	in	r28, 0x3d	; 61
    159c:	de b7       	in	r29, 0x3e	; 62

    static semi_truck_data_t semi_truck_data = {0};
    //auto comm_data = new communication_data(&semi_truck_data);
    //rs232 *p_ser_port = new rs232 (9600, 1);
    
	servo serv1 = servo();
    159e:	ce 01       	movw	r24, r28
    15a0:	01 96       	adiw	r24, 0x01	; 1
    15a2:	0e 94 14 02 	call	0x428	; 0x428 <_ZN5servoC1Ev>
    fifth_wheel *fifth = new fifth_wheel("fifth_wheel", 1, 200, nullptr, &semi_truck_data);
    15a6:	85 e1       	ldi	r24, 0x15	; 21
    15a8:	90 e0       	ldi	r25, 0x00	; 0
    15aa:	0e 94 da 04 	call	0x9b4	; 0x9b4 <_Znwj>
    15ae:	0f 2e       	mov	r0, r31
    15b0:	fc e8       	ldi	r31, 0x8C	; 140
    15b2:	ef 2e       	mov	r14, r31
    15b4:	fc e0       	ldi	r31, 0x0C	; 12
    15b6:	ff 2e       	mov	r15, r31
    15b8:	f0 2d       	mov	r31, r0
    15ba:	00 e0       	ldi	r16, 0x00	; 0
    15bc:	10 e0       	ldi	r17, 0x00	; 0
    15be:	28 ec       	ldi	r18, 0xC8	; 200
    15c0:	30 e0       	ldi	r19, 0x00	; 0
    15c2:	41 e0       	ldi	r20, 0x01	; 1
    15c4:	65 e6       	ldi	r22, 0x65	; 101
    15c6:	71 e0       	ldi	r23, 0x01	; 1
    15c8:	0e 94 65 00 	call	0xca	; 0xca <_ZN11fifth_wheelC1EPKchjP8emstreamP17semi_truck_data_t>
    gear_shifter *shifter = new gear_shifter("gear_shifter", 1, 200, nullptr, &semi_truck_data);
    15cc:	84 e1       	ldi	r24, 0x14	; 20
    15ce:	90 e0       	ldi	r25, 0x00	; 0
    15d0:	0e 94 da 04 	call	0x9b4	; 0x9b4 <_Znwj>
    15d4:	28 ec       	ldi	r18, 0xC8	; 200
    15d6:	30 e0       	ldi	r19, 0x00	; 0
    15d8:	41 e0       	ldi	r20, 0x01	; 1
    15da:	61 e7       	ldi	r22, 0x71	; 113
    15dc:	71 e0       	ldi	r23, 0x01	; 1
    15de:	0e 94 d6 00 	call	0x1ac	; 0x1ac <_ZN12gear_shifterC1EPKchjP8emstreamP17semi_truck_data_t>
    imu_task *imu = new imu_task("imu", 5, 400, nullptr, 0, 0, nullptr);
    15e2:	8d e1       	ldi	r24, 0x1D	; 29
    15e4:	90 e0       	ldi	r25, 0x00	; 0
    15e6:	0e 94 da 04 	call	0x9b4	; 0x9b4 <_Znwj>
    15ea:	81 2c       	mov	r8, r1
    15ec:	91 2c       	mov	r9, r1
    15ee:	a1 2c       	mov	r10, r1
    15f0:	c1 2c       	mov	r12, r1
    15f2:	d1 2c       	mov	r13, r1
    15f4:	76 01       	movw	r14, r12
    15f6:	20 e9       	ldi	r18, 0x90	; 144
    15f8:	31 e0       	ldi	r19, 0x01	; 1
    15fa:	45 e0       	ldi	r20, 0x05	; 5
    15fc:	6e e7       	ldi	r22, 0x7E	; 126
    15fe:	71 e0       	ldi	r23, 0x01	; 1
    1600:	0e 94 ca 01 	call	0x394	; 0x394 <_ZN8imu_taskC1EPKchjP8emstreammhP17semi_truck_data_t>
    //auto comm = new mega_comm_task("communicator", 5, 500, nullptr, 9600, 1, comm_data); // works with non-reference to comm data?
    motor_driver *motor = new motor_driver("motor", 6, 400, nullptr, &semi_truck_data);
    1604:	84 e1       	ldi	r24, 0x14	; 20
    1606:	90 e0       	ldi	r25, 0x00	; 0
    1608:	0e 94 da 04 	call	0x9b4	; 0x9b4 <_Znwj>
    160c:	0f 2e       	mov	r0, r31
    160e:	fc e8       	ldi	r31, 0x8C	; 140
    1610:	ef 2e       	mov	r14, r31
    1612:	fc e0       	ldi	r31, 0x0C	; 12
    1614:	ff 2e       	mov	r15, r31
    1616:	f0 2d       	mov	r31, r0
    1618:	20 e9       	ldi	r18, 0x90	; 144
    161a:	31 e0       	ldi	r19, 0x01	; 1
    161c:	46 e0       	ldi	r20, 0x06	; 6
    161e:	62 e8       	ldi	r22, 0x82	; 130
    1620:	71 e0       	ldi	r23, 0x01	; 1
    1622:	0e 94 fe 01 	call	0x3fc	; 0x3fc <_ZN12motor_driverC1EPKchjP8emstreamP17semi_truck_data_t>
    steer_servo *steering = new steer_servo("steering", 6, 400, nullptr, nullptr);
    1626:	84 e1       	ldi	r24, 0x14	; 20
    1628:	90 e0       	ldi	r25, 0x00	; 0
    162a:	0e 94 da 04 	call	0x9b4	; 0x9b4 <_Znwj>
    162e:	e1 2c       	mov	r14, r1
    1630:	f1 2c       	mov	r15, r1
    1632:	20 e9       	ldi	r18, 0x90	; 144
    1634:	31 e0       	ldi	r19, 0x01	; 1
    1636:	46 e0       	ldi	r20, 0x06	; 6
    1638:	68 e8       	ldi	r22, 0x88	; 136
    163a:	71 e0       	ldi	r23, 0x01	; 1
    163c:	0e 94 1f 02 	call	0x43e	; 0x43e <_ZN11steer_servoC1EPKchjP8emstreamP17semi_truck_data_t>
    wheel_speed *speed = new wheel_speed("speed sensor", 9, 400, nullptr, nullptr);
    1640:	84 e1       	ldi	r24, 0x14	; 20
    1642:	90 e0       	ldi	r25, 0x00	; 0
    1644:	0e 94 da 04 	call	0x9b4	; 0x9b4 <_Znwj>
    1648:	20 e9       	ldi	r18, 0x90	; 144
    164a:	31 e0       	ldi	r19, 0x01	; 1
    164c:	49 e0       	ldi	r20, 0x09	; 9
    164e:	61 e9       	ldi	r22, 0x91	; 145
    1650:	71 e0       	ldi	r23, 0x01	; 1
    1652:	0e 94 4e 02 	call	0x49c	; 0x49c <_ZN11wheel_speedC1EPKchjP8emstreamP17semi_truck_data_t>


    /// the actual freeRTOS function that runs the scheduler
}
    1656:	80 e0       	ldi	r24, 0x00	; 0
    1658:	90 e0       	ldi	r25, 0x00	; 0
    165a:	0f 90       	pop	r0
    165c:	df 91       	pop	r29
    165e:	cf 91       	pop	r28
    1660:	1f 91       	pop	r17
    1662:	0f 91       	pop	r16
    1664:	ff 90       	pop	r15
    1666:	ef 90       	pop	r14
    1668:	df 90       	pop	r13
    166a:	cf 90       	pop	r12
    166c:	af 90       	pop	r10
    166e:	9f 90       	pop	r9
    1670:	8f 90       	pop	r8
    1672:	08 95       	ret

00001674 <memset>:
    1674:	dc 01       	movw	r26, r24
    1676:	01 c0       	rjmp	.+2      	; 0x167a <memset+0x6>
    1678:	6d 93       	st	X+, r22
    167a:	41 50       	subi	r20, 0x01	; 1
    167c:	50 40       	sbci	r21, 0x00	; 0
    167e:	e0 f7       	brcc	.-8      	; 0x1678 <memset+0x4>
    1680:	08 95       	ret

00001682 <strncpy>:
    1682:	fb 01       	movw	r30, r22
    1684:	dc 01       	movw	r26, r24
    1686:	41 50       	subi	r20, 0x01	; 1
    1688:	50 40       	sbci	r21, 0x00	; 0
    168a:	48 f0       	brcs	.+18     	; 0x169e <strncpy+0x1c>
    168c:	01 90       	ld	r0, Z+
    168e:	0d 92       	st	X+, r0
    1690:	00 20       	and	r0, r0
    1692:	c9 f7       	brne	.-14     	; 0x1686 <strncpy+0x4>
    1694:	01 c0       	rjmp	.+2      	; 0x1698 <strncpy+0x16>
    1696:	1d 92       	st	X+, r1
    1698:	41 50       	subi	r20, 0x01	; 1
    169a:	50 40       	sbci	r21, 0x00	; 0
    169c:	e0 f7       	brcc	.-8      	; 0x1696 <strncpy+0x14>
    169e:	08 95       	ret

000016a0 <_exit>:
    16a0:	f8 94       	cli

000016a2 <__stop_program>:
    16a2:	ff cf       	rjmp	.-2      	; 0x16a2 <__stop_program>
